package event

import (
	"context"
	"fmt"
	"math"
	"net/http"
	"time"

	"github.com/google/uuid"
	"github.com/labstack/echo/v4"
	"github.com/lands-horizon/horizon-server/src/model"
)

type TransactionType string

const (
	TransactionTypeDeposit  TransactionType = "deposit"
	TransactionTypeWithdraw TransactionType = "withdraw"
)

type PaymentEvent struct {
	Amount                float64         `json:"amount" validate:"required"`
	SignatureMediaID      *uuid.UUID      `json:"signature_media_id,omitempty"`
	ProofOfPaymentMediaID *uuid.UUID      `json:"proof_of_payment_media_id,omitempty"`
	BankID                *uuid.UUID      `json:"bank_id,omitempty"`
	BankReferenceNumber   string          `json:"bank_reference_number,omitempty"`
	EntryDate             *time.Time      `json:"entry_date,omitempty"`
	ReferenceNumber       string          `json:"reference_number,omitempty"`
	AccountID             *uuid.UUID      `json:"account_id,omitempty"`
	MemberProfileID       *uuid.UUID      `json:"member_profile_id,omitempty"`
	MemberJointAccountID  *uuid.UUID      `json:"member_joint_account_id,omitempty"`
	PaymentTypeID         *uuid.UUID      `json:"payment_type_id,omitempty"`
	Description           string          `json:"description,omitempty" validate:"max=255"`
	TransactionType       TransactionType `json:"transaction_type" validate:"required,oneof=DEPOSIT WITHDRAW"`
	ORAutoGenerated       bool            `json:"or_auto_generated,omitempty"`
}

func (e *Event) Payment(context context.Context, ctx echo.Context, data PaymentEvent, transactionId *uuid.UUID) error {
	if data.Amount == 0 {
		e.Footstep(context, ctx, FootstepEvent{
			Activity:    "payment-error",
			Description: "Payment amount cannot be zero (/transaction/withdraw/:transaction_id)",
			Module:      "Transaction",
		})
		return ctx.JSON(http.StatusBadRequest, map[string]string{"error": "Payment amount cannot be zero"})
	}
	// Current user Organization
	userOrg, err := e.userOrganizationToken.CurrentUserOrganization(context, ctx)
	if err != nil {
		e.Footstep(context, ctx, FootstepEvent{
			Activity:    "auth-error",
			Description: "Failed to get user organization (/transaction/withdraw/:transaction_id): " + err.Error(),
			Module:      "Transaction",
		})
		return ctx.JSON(http.StatusUnauthorized, map[string]string{"error": "Failed to get user organization: " + err.Error()})
	}

	// Get current TransactionBatch
	transactionBatch, err := e.model.TransactionBatchCurrent(context, userOrg.UserID, userOrg.OrganizationID, *userOrg.BranchID)
	if err != nil {
		e.Footstep(context, ctx, FootstepEvent{
			Activity:    "batch-error",
			Description: "Failed to retrieve transaction batch (/transaction/withdraw/:transaction_id): " + err.Error(),
			Module:      "Transaction",
		})
		return ctx.JSON(http.StatusForbidden, map[string]string{"error": "Failed to retrieve transaction batch: " + err.Error()})
	}

	account, err := e.model.AccountManager.GetByID(context, *data.AccountID)
	if err != nil {
		e.Footstep(context, ctx, FootstepEvent{
			Activity:    "account-error",
			Description: "Failed to retrieve account (/transaction/withdraw/:transaction_id): " + err.Error(),
			Module:      "Transaction",
		})
		return ctx.JSON(http.StatusForbidden, map[string]string{"error": "Failed to retrieve account: " + err.Error()})
	}

	paymentType, err := e.model.PaymentTypeManager.GetByID(context, *data.PaymentTypeID)
	if err != nil {
		e.Footstep(context, ctx, FootstepEvent{
			Activity:    "payment-type-error",
			Description: "Failed to retrieve payment type (/transaction/withdraw/:transaction_id): " + err.Error(),
			Module:      "Transaction",
		})
		return ctx.JSON(http.StatusForbidden, map[string]string{"error": "Failed to retrieve payment type: " + err.Error()})
	}

	// Begin DB transaction for race condition protection --------------------------
	tx := e.provider.Service.Database.Client().Begin()
	if tx.Error != nil {
		tx.Rollback()
		e.Footstep(context, ctx, FootstepEvent{
			Activity:    "db-error",
			Description: "Withdraw failed: begin tx error (/transaction/withdraw/:transaction_id): " + tx.Error.Error(),
			Module:      "Transaction",
		})
		return ctx.JSON(http.StatusInternalServerError, map[string]string{"error": "Failed to start transaction: " + tx.Error.Error()})
	}
	defer func() {
		if r := recover(); r != nil {
			tx.Rollback()
		}
	}()

	// >>>>>>>>>>>>>>>> RACE CONDITION PROTECTION <<<<<<<<<<<<<<<<
	// Lock the latest general ledger entry for update, so concurrent withdrawals can't double-spend.
	generalLedger, err := e.model.GeneralLedgerCurrentMemberAccountForUpdate(
		context, tx, *data.MemberProfileID, *data.AccountID, userOrg.OrganizationID, *userOrg.BranchID)
	if err != nil {
		tx.Rollback()
		e.Footstep(context, ctx, FootstepEvent{
			Activity:    "ledger-error",
			Description: "Failed to retrieve general ledger (FOR UPDATE) (/transaction/withdraw/:transaction_id): " + err.Error(),
			Module:      "Transaction",
		})
		return ctx.JSON(http.StatusForbidden, map[string]string{"error": "Failed to retrieve general ledger: " + err.Error()})
	}
	// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

	// Computation
	var credit, debit, newBalance float64
	switch account.Type {
	case model.AccountTypeDeposit:
		if data.TransactionType == TransactionTypeDeposit {
			credit = data.Amount
			debit = 0
			if generalLedger != nil {
				newBalance = generalLedger.Balance + data.Amount
			} else {
				newBalance = data.Amount
			}
		} else { // Withdraw
			if generalLedger == nil || generalLedger.Balance < data.Amount {
				tx.Rollback()
				e.Footstep(context, ctx, FootstepEvent{
					Activity:    "balance-error",
					Description: "Insufficient balance for withdrawal (/transaction/payment/:transaction_id)",
					Module:      "Transaction",
				})
				return ctx.JSON(http.StatusBadRequest, map[string]string{"error": "Insufficient balance for withdrawal"})
			}
			credit = 0
			debit = data.Amount
			newBalance = generalLedger.Balance - data.Amount
		}
	case model.AccountTypeLoan:
		if data.TransactionType == TransactionTypeDeposit {
			credit = 0
			debit = data.Amount
			if generalLedger != nil {
				newBalance = generalLedger.Balance - data.Amount
			} else {
				newBalance = -data.Amount
			}
		} else {
			credit = data.Amount
			debit = 0
			if generalLedger != nil {
				newBalance = generalLedger.Balance + data.Amount
			} else {
				newBalance = data.Amount
			}
		}
	case model.AccountTypeARLedger, model.AccountTypeARAging, model.AccountTypeFines, model.AccountTypeInterest, model.AccountTypeSVFLedger, model.AccountTypeWOff, model.AccountTypeAPLedger:
		if data.TransactionType == TransactionTypeDeposit {
			credit = 0
			debit = data.Amount
			if generalLedger != nil {
				newBalance = generalLedger.Balance - data.Amount
			} else {
				newBalance = -data.Amount
			}
		} else {
			credit = data.Amount
			debit = 0
			if generalLedger != nil {
				newBalance = generalLedger.Balance + data.Amount
			} else {
				newBalance = data.Amount
			}
		}
	case model.AccountTypeOther:
		if data.TransactionType == TransactionTypeDeposit {
			credit = data.Amount
			debit = 0
			if generalLedger != nil {
				newBalance = generalLedger.Balance + data.Amount
			} else {
				newBalance = data.Amount
			}
		} else {
			if generalLedger == nil || generalLedger.Balance < data.Amount {
				tx.Rollback()
				e.Footstep(context, ctx, FootstepEvent{
					Activity:    "balance-error",
					Description: "Insufficient balance for withdrawal (/transaction/payment/:transaction_id)",
					Module:      "Transaction",
				})
				return ctx.JSON(http.StatusBadRequest, map[string]string{"error": "Insufficient balance for withdrawal"})
			}
			credit = 0
			debit = data.Amount
			newBalance = generalLedger.Balance - data.Amount
		}
	default:
		tx.Rollback()
		e.Footstep(context, ctx, FootstepEvent{
			Activity:    "account-type-error",
			Description: "Unsupported account type (/transaction/payment/:transaction_id)",
			Module:      "Transaction",
		})
		return ctx.JSON(http.StatusBadRequest, map[string]string{"error": "Unsupported account type"})
	}

	// Validate against account min/max limits (only if at least one is non-zero)
	if (account.MinAmount != 0 || account.MaxAmount != 0) &&
		(newBalance < account.MinAmount || newBalance > account.MaxAmount) {
		tx.Rollback()
		e.Footstep(context, ctx, FootstepEvent{
			Activity: "balance-limit-error",
			Description: fmt.Sprintf(
				"Balance %.2f exceeds account limits [%.2f-%.2f] (%s)",
				newBalance,
				account.MinAmount,
				account.MaxAmount,
				"/transaction/payment/:transaction_id",
			),
			Module: "Transaction",
		})
		return ctx.JSON(http.StatusBadRequest, map[string]string{
			"error": fmt.Sprintf(
				"Account balance must be between %.2f and %.2f. Result would be %.2f",
				account.MinAmount,
				account.MaxAmount,
				newBalance,
			),
		})
	}
	transaction := &model.Transaction{}
	if transactionId != nil {
		transaction, err = e.model.TransactionManager.GetByID(context, *transactionId)
		if err != nil {
			tx.Rollback()
			e.Footstep(context, ctx, FootstepEvent{
				Activity:    "transaction-error",
				Description: "Failed to retrieve transaction (/transaction/payment/:transaction_id): " + err.Error(),
				Module:      "Transaction",
			})
			return ctx.JSON(http.StatusForbidden, map[string]string{"error": "Failed to retrieve transaction: " + err.Error()})
		}
		if transaction.TransactionBatchID == nil || *transaction.TransactionBatchID != transactionBatch.ID {
			tx.Rollback()
			e.Footstep(context, ctx, FootstepEvent{
				Activity:    "transaction-batch-mismatch",
				Description: "Transaction does not belong to the current transaction batch (/transaction/payment/:transaction_id)",
				Module:      "Transaction",
			})
			return ctx.JSON(http.StatusForbidden, map[string]string{
				"error": "Transaction does not belong to the current transaction batch",
			})
		}
	} else {
		transaction = &model.Transaction{
			CreatedAt:            time.Now().UTC(),
			CreatedByID:          userOrg.UserID,
			UpdatedAt:            time.Now().UTC(),
			UpdatedByID:          userOrg.UserID,
			BranchID:             *userOrg.BranchID,
			OrganizationID:       userOrg.OrganizationID,
			SignatureMediaID:     data.SignatureMediaID,
			TransactionBatchID:   &transactionBatch.ID,
			EmployeeUserID:       &userOrg.UserID,
			MemberProfileID:      data.MemberProfileID,
			MemberJointAccountID: data.MemberJointAccountID,
			Amount:               data.Amount,
			ReferenceNumber:      data.ReferenceNumber,
			Source:               model.GeneralLedgerSourceDeposit,
			Description:          data.Description,
			LoanBalance:          0,
			LoanDue:              0,
			TotalDue:             0,
			FinesDue:             0,
			TotalLoan:            0,
			InterestDue:          0,
		}
		if err := e.model.TransactionManager.CreateWithTx(context, tx, transaction); err != nil {
			tx.Rollback()
			e.Footstep(context, ctx, FootstepEvent{
				Activity:    "transaction-create-error",
				Description: "Failed to create transaction (/transaction/payment/:transaction_id): " + err.Error(),
				Module:      "Transaction",
			})
			return ctx.JSON(http.StatusInternalServerError, map[string]string{"error": "Failed to create transaction: " + err.Error()})
		}
	}
	newGeneralLedger := &model.GeneralLedger{
		CreatedAt:                  time.Now().UTC(),
		CreatedByID:                userOrg.UserID,
		UpdatedAt:                  time.Now().UTC(),
		UpdatedByID:                userOrg.UserID,
		BranchID:                   *userOrg.BranchID,
		OrganizationID:             userOrg.OrganizationID,
		TransactionBatchID:         &transactionBatch.ID,
		ReferenceNumber:            data.ReferenceNumber,
		TransactionID:              &transaction.ID,
		EntryDate:                  data.EntryDate,
		SignatureMediaID:           data.SignatureMediaID,
		ProofOfPaymentMediaID:      data.ProofOfPaymentMediaID,
		BankID:                     data.BankID,
		AccountID:                  &account.ID,
		Credit:                     credit,
		Debit:                      debit,
		Balance:                    newBalance,
		MemberProfileID:            data.MemberProfileID,
		MemberJointAccountID:       data.MemberJointAccountID,
		PaymentTypeID:              &paymentType.ID,
		TransactionReferenceNumber: data.ReferenceNumber,
		Source:                     model.GeneralLedgerSourceDeposit,
		BankReferenceNumber:        data.BankReferenceNumber,
		EmployeeUserID:             &userOrg.UserID,
		Description:                data.Description,
	}
	if err := e.model.GeneralLedgerManager.CreateWithTx(context, tx, newGeneralLedger); err != nil {
		tx.Rollback()
		e.Footstep(context, ctx, FootstepEvent{
			Activity:    "ledger-create-error",
			Description: "Failed to create quick deposit entry (/transaction/deposit): " + err.Error(),
			Module:      "Transaction",
		})
		return ctx.JSON(http.StatusInternalServerError, map[string]string{"error": "Failed to create quick deposit entry: " + err.Error()})
	}

	// update transaction
	if data.TransactionType == TransactionTypeDeposit {
		transaction.Amount += data.Amount
	} else {
		transaction.Amount -= data.Amount
	}
	if err := e.model.TransactionManager.UpdateFieldsWithTx(context, tx, transaction.ID, transaction); err != nil {
		tx.Rollback()
		e.Footstep(context, ctx, FootstepEvent{
			Activity:    "transaction-update-error",
			Description: fmt.Sprintf("Transaction update failed (%s): %s", ctx.Path(), err.Error()),
			Module:      "Transaction",
		})
		return ctx.JSON(http.StatusInternalServerError, map[string]string{
			"error": "Failed to update transaction: " + err.Error(),
		})
	}

	// update transaction batch
	if data.TransactionType == TransactionTypeDeposit {
		switch paymentType.Type {
		case model.PaymentTypeCash:
			transactionBatch.TotalCashCollection += data.Amount
		case model.PaymentTypeCheck:
			transactionBatch.TotalCheckRemittance += data.Amount
		case model.PaymentTypeOnline:
			transactionBatch.TotalOnlineRemittance += data.Amount
		}
	} else {
		switch account.Type {
		case model.AccountTypeDeposit:
			transactionBatch.SavingsWithdrawal += data.Amount
		case model.AccountTypeLoan:
			transactionBatch.LoanReleases += data.Amount
		case model.AccountTypeTimeDeposit:
			transactionBatch.TimeDepositWithdrawal += data.Amount
		default:
			transactionBatch.PettyCash += data.Amount
		}
	}

	// Update calculated balances
	transactionBatch.UpdatedAt = time.Now().UTC()
	transactionBatch.UpdatedByID = userOrg.UserID
	transactionBatch.TotalCashHandled = transactionBatch.BeginningBalance +
		transactionBatch.TotalCashCollection -
		(transactionBatch.PettyCash + transactionBatch.LoanReleases +
			transactionBatch.TimeDepositWithdrawal + transactionBatch.SavingsWithdrawal)

	transactionBatch.TotalSupposedRemitance = transactionBatch.TotalCashHandled
	transactionBatch.TotalActualRemittance = transactionBatch.TotalCheckRemittance +
		transactionBatch.TotalOnlineRemittance +
		transactionBatch.TotalCashOnHand +
		transactionBatch.TotalDepositInBank

	transactionBatch.TotalActualSupposedComparison = math.Abs(transactionBatch.TotalSupposedRemitance) +
		math.Abs(transactionBatch.TotalActualRemittance)

	// Save the updated transaction batch
	if err := e.model.TransactionBatchManager.UpdateWithTx(context, tx, transactionBatch); err != nil {
		tx.Rollback()
		e.Footstep(context, ctx, FootstepEvent{
			Activity:    "batch-update-error",
			Description: "Failed to update transaction batch (/transaction/payment/:transaction_id): " + err.Error(),
			Module:      "Transaction",
		})
		return ctx.JSON(http.StatusInternalServerError, map[string]string{
			"error": "Failed to update transaction batch: " + err.Error(),
		})
	}
	if err := e.model.TransactionBatchManager.UpdateFieldsWithTx(context, tx, transactionBatch.ID, transactionBatch); err != nil {
		tx.Rollback()
		e.Footstep(context, ctx, FootstepEvent{
			Activity:    "batch-update-fields-error",
			Description: "Failed to update transaction batch fields (/transaction/payment/:transaction_id): " + err.Error(),
			Module:      "Transaction",
		})
		return ctx.JSON(http.StatusInternalServerError, map[string]string{
			"error": "Failed to update transaction batch fields: " + err.Error(),
		})
	}
	lastPayTime := time.Now().UTC()
	if data.EntryDate != nil {
		lastPayTime = time.Now().UTC()
	}

	// update or create member accounting ledger
	memberAccountingLedger, _ := e.model.MemberAccountingLedgerManager.FindOne(context, &model.MemberAccountingLedger{
		MemberProfileID: *data.MemberProfileID,
		AccountID:       *data.AccountID,
		BranchID:        *userOrg.BranchID,
		OrganizationID:  userOrg.OrganizationID,
	})
	if memberAccountingLedger == nil {
		// Create new member accounting ledger
		memberAccountingLedger = &model.MemberAccountingLedger{
			CreatedAt:       time.Now().UTC(),
			CreatedByID:     userOrg.UserID,
			UpdatedAt:       time.Now().UTC(),
			UpdatedByID:     userOrg.UserID,
			OrganizationID:  userOrg.OrganizationID,
			BranchID:        *userOrg.BranchID,
			MemberProfileID: *data.MemberProfileID,
			AccountID:       *data.AccountID,
			Balance:         newBalance,
			LastPay:         &lastPayTime,
			// Initialize other fields to zero
			Count:               0,
			Interest:            0,
			Fines:               0,
			Due:                 0,
			CarriedForwardDue:   0,
			StoredValueFacility: 0,
			PrincipalDue:        0,
		}
		if err := e.model.MemberAccountingLedgerManager.CreateWithTx(context, tx, memberAccountingLedger); err != nil {
			tx.Rollback()
			e.Footstep(context, ctx, FootstepEvent{
				Activity:    "member-accounting-ledger-create-error",
				Description: "Failed to create member accounting ledger (/transaction/payment/:transaction_id): " + err.Error(),
				Module:      "Transaction",
			})
			return ctx.JSON(http.StatusInternalServerError, map[string]string{
				"error": "Failed to create member accounting ledger: " + err.Error(),
			})
		}
	} else {
		// Update existing member accounting ledger
		memberAccountingLedger.Balance = newBalance
		memberAccountingLedger.LastPay = &lastPayTime
		memberAccountingLedger.UpdatedAt = time.Now().UTC()
		memberAccountingLedger.UpdatedByID = userOrg.UserID

		// Increment transaction count
		memberAccountingLedger.Count += 1

		if err := e.model.MemberAccountingLedgerManager.UpdateFieldsWithTx(context, tx, memberAccountingLedger.ID, memberAccountingLedger); err != nil {
			tx.Rollback()
			e.Footstep(context, ctx, FootstepEvent{
				Activity:    "member-accounting-ledger-update-error",
				Description: "Failed to update member accounting ledger (/transaction/payment/:transaction_id): " + err.Error(),
				Module:      "Transaction",
			})
			return ctx.JSON(http.StatusInternalServerError, map[string]string{
				"error": "Failed to update member accounting ledger: " + err.Error(),
			})
		}
	}
	if data.ORAutoGenerated {
		if userOrg.UserSettingUsedOR >= userOrg.UserSettingEndOR {
			tx.Rollback()
			e.Footstep(context, ctx, FootstepEvent{
				Activity:    "or-limit-reached",
				Description: "User has reached the limit of OR usage (/transaction/payment/:transaction_id)",
				Module:      "Transaction",
			})
			return ctx.JSON(http.StatusForbidden, map[string]string{
				"error": "User has reached the limit of OR usage",
			})
		}
		userOrg.UserSettingUsedOR = userOrg.UserSettingUsedOR + 1

		if err := e.model.UserOrganizationManager.UpdateFieldsWithTx(context, tx, userOrg.ID, userOrg); err != nil {
			tx.Rollback()
			e.Footstep(context, ctx, FootstepEvent{
				Activity:    "user-org-update-error",
				Description: "Failed to update user organization OR usage (/transaction/payment/:transaction_id): " + err.Error(),
				Module:      "Transaction",
			})
			return ctx.JSON(http.StatusInternalServerError, map[string]string{
				"error": "Failed to update user organization OR usage: " + err.Error(),
			})
		}
	}
	if err := tx.Commit().Error; err != nil {
		e.Footstep(context, ctx, FootstepEvent{
			Activity:    "db-commit-error",
			Description: "Failed to commit transaction (/transaction/payment/:transaction_id): " + err.Error(),
			Module:      "Transaction",
		})
		return ctx.JSON(http.StatusInternalServerError, map[string]string{
			"error": "Failed to commit transaction: " + err.Error(),
		})
	}
	return ctx.JSON(http.StatusOK, e.model.GeneralLedgerManager.ToModel(newGeneralLedger))
}

func (e *Event) Withdraw(context context.Context, ctx echo.Context, data PaymentEvent) error {

	// Current user Organization
	userOrg, err := e.userOrganizationToken.CurrentUserOrganization(context, ctx)
	if err != nil {
		e.Footstep(context, ctx, FootstepEvent{
			Activity:    "auth-error",
			Description: "Failed to get user organization (/transaction/withdraw/:transaction_id): " + err.Error(),
			Module:      "Transaction",
		})
		return ctx.JSON(http.StatusUnauthorized, map[string]string{"error": "Failed to get user organization: " + err.Error()})
	}
	// Get current TransactionBatch
	transactionBatch, err := e.model.TransactionBatchCurrent(context, userOrg.UserID, userOrg.OrganizationID, *userOrg.BranchID)
	if err != nil {
		e.Footstep(context, ctx, FootstepEvent{
			Activity:    "batch-error",
			Description: "Failed to retrieve transaction batch (/transaction/withdraw/:transaction_id): " + err.Error(),
			Module:      "Transaction",
		})
		return ctx.JSON(http.StatusForbidden, map[string]string{"error": "Failed to retrieve transaction batch: " + err.Error()})
	}

	transaction := &model.Transaction{
		CreatedAt:            time.Now().UTC(),
		CreatedByID:          userOrg.UserID,
		UpdatedAt:            time.Now().UTC(),
		UpdatedByID:          userOrg.UserID,
		BranchID:             *userOrg.BranchID,
		OrganizationID:       userOrg.OrganizationID,
		SignatureMediaID:     data.SignatureMediaID,
		TransactionBatchID:   &transactionBatch.ID,
		EmployeeUserID:       &userOrg.UserID,
		MemberProfileID:      data.MemberProfileID,
		MemberJointAccountID: data.MemberJointAccountID,
		Amount:               data.Amount,
		ReferenceNumber:      data.ReferenceNumber,
		Source:               model.GeneralLedgerSourceDeposit,
		Description:          data.Description,
		LoanBalance:          0,
		LoanDue:              0,
		TotalDue:             0,
		FinesDue:             0,
		TotalLoan:            0,
		InterestDue:          0,
	}
	if err := e.model.TransactionManager.Create(context, transaction); err != nil {
		e.Footstep(context, ctx, FootstepEvent{
			Activity:    "transaction-create-error",
			Description: "Failed to create transaction (/transaction/withdraw/:transaction_id): " + err.Error(),
			Module:      "Transaction",
		})
		return ctx.JSON(http.StatusInternalServerError, map[string]string{"error": "Failed to create transaction: " + err.Error()})
	}
	data.TransactionType = TransactionTypeWithdraw
	return e.Payment(context, ctx, data, &transaction.ID)
}

func (e *Event) Deposit(context context.Context, ctx echo.Context, data PaymentEvent) error {
	// Current user Organization
	userOrg, err := e.userOrganizationToken.CurrentUserOrganization(context, ctx)
	if err != nil {
		e.Footstep(context, ctx, FootstepEvent{
			Activity:    "auth-error",
			Description: "Failed to get user organization (/transaction/withdraw/:transaction_id): " + err.Error(),
			Module:      "Transaction",
		})
		return ctx.JSON(http.StatusUnauthorized, map[string]string{"error": "Failed to get user organization: " + err.Error()})
	}
	// Get current TransactionBatch
	transactionBatch, err := e.model.TransactionBatchCurrent(context, userOrg.UserID, userOrg.OrganizationID, *userOrg.BranchID)
	if err != nil {
		e.Footstep(context, ctx, FootstepEvent{
			Activity:    "batch-error",
			Description: "Failed to retrieve transaction batch (/transaction/withdraw/:transaction_id): " + err.Error(),
			Module:      "Transaction",
		})
		return ctx.JSON(http.StatusForbidden, map[string]string{"error": "Failed to retrieve transaction batch: " + err.Error()})
	}

	transaction := &model.Transaction{
		CreatedAt:            time.Now().UTC(),
		CreatedByID:          userOrg.UserID,
		UpdatedAt:            time.Now().UTC(),
		UpdatedByID:          userOrg.UserID,
		BranchID:             *userOrg.BranchID,
		OrganizationID:       userOrg.OrganizationID,
		SignatureMediaID:     data.SignatureMediaID,
		TransactionBatchID:   &transactionBatch.ID,
		EmployeeUserID:       &userOrg.UserID,
		MemberProfileID:      data.MemberProfileID,
		MemberJointAccountID: data.MemberJointAccountID,
		Amount:               data.Amount,
		ReferenceNumber:      data.ReferenceNumber,
		Source:               model.GeneralLedgerSourceDeposit,
		Description:          data.Description,
		LoanBalance:          0,
		LoanDue:              0,
		TotalDue:             0,
		FinesDue:             0,
		TotalLoan:            0,
		InterestDue:          0,
	}
	if err := e.model.TransactionManager.Create(context, transaction); err != nil {
		e.Footstep(context, ctx, FootstepEvent{
			Activity:    "transaction-create-error",
			Description: "Failed to create transaction (/transaction/withdraw/:transaction_id): " + err.Error(),
			Module:      "Transaction",
		})
		return ctx.JSON(http.StatusInternalServerError, map[string]string{"error": "Failed to create transaction: " + err.Error()})
	}
	data.TransactionType = TransactionTypeDeposit
	return e.Payment(context, ctx, data, &transaction.ID)
}
