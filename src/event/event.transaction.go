package event

import (
	"context"
	"errors"
	"fmt"
	"time"

	"github.com/Lands-Horizon-Corp/e-coop-server/horizon"
	"github.com/Lands-Horizon-Corp/e-coop-server/src/core"
	"github.com/Lands-Horizon-Corp/e-coop-server/src/types"
	"github.com/Lands-Horizon-Corp/e-coop-server/src/usecase"
	"github.com/google/uuid"
	"github.com/labstack/echo/v4"
	"github.com/rotisserie/eris"
	"github.com/shopspring/decimal"
	"gorm.io/gorm"
)

type TransactionEvent struct {
	Amount               float64    `json:"amount" validate:"required"`
	AccountID            *uuid.UUID `json:"account_id" validate:"required"`
	PaymentTypeID        *uuid.UUID `json:"payment_type_id" validate:"required"`
	TransactionID        *uuid.UUID `json:"transaction_id"`
	MemberProfileID      *uuid.UUID `json:"member_profile_id"`
	SignatureMediaID     *uuid.UUID `json:"signature_media_id"`
	MemberJointAccountID *uuid.UUID `json:"member_joint_account_id"`
	LoanTransactionID    *uuid.UUID `json:"loan_transaction_id"`

	Source types.GeneralLedgerSource `json:"source" validate:"required"`

	EntryDate             *time.Time `json:"entry_date"`
	BankID                *uuid.UUID `json:"bank_id"`
	ProofOfPaymentMediaID *uuid.UUID `json:"proof_of_payment_media_id"`

	ReferenceNumber     string `json:"reference_number" validate:"required"`
	Description         string `json:"description" validate:"required"`
	BankReferenceNumber string `json:"bank_reference_number"`
	ORAutoGenerated     bool   `json:"or_auto_generated"`
	Reverse             bool   `json:"reverse"`
}

func TransactionPayment(
	context context.Context, service *horizon.HorizonService,
	ctx echo.Context,
	tx *gorm.DB,
	endTx func(error) error,
	data TransactionEvent,
) (*types.GeneralLedger, error) {
	fmt.Println("DEBUG: TransactionPayment started")
	startTime := time.Now()
	defer func() {
		duration := time.Since(startTime)
		if duration > 5*time.Second {
			Footstep(ctx, service, FootstepEvent{
				Activity:    "performance-warning",
				Description: fmt.Sprintf("Payment operation took %.2fs - potential performance issue (/transaction/payment/:transaction_id)", duration.Seconds()),
				Module:      "Transaction",
			})
		}
	}()

	fmt.Println("DEBUG: Calling HandleIPBlocker")
	block, blocked, err := HandleIPBlocker(context, service, ctx)
	if err != nil {
		return nil, endTx(eris.Wrap(err, "internal error during IP block check"))
	}
	if block == nil {
		return nil, endTx(eris.New("IP blocker function is nil"))
	}
	if blocked {
		return nil, endTx(eris.New("IP is temporarily blocked due to repeated errors"))
	}
	fmt.Println("DEBUG: Calling CurrentUserOrganization")
	userOrg, err := CurrentUserOrganization(context, service, ctx)
	fmt.Println("DEBUG: CurrentUserOrganization result - error:", err, "userOrg nil:", userOrg == nil)
	if err != nil {
		return nil, endTx(eris.Wrap(err, "failed to get user organization"))
	}
	if userOrg == nil {
		return nil, endTx(eris.New("user organization is nil"))
	}
	fmt.Println("DEBUG: userOrg BranchID nil:", userOrg.BranchID == nil)
	if userOrg.BranchID == nil {
		return nil, endTx(eris.New("user organization branch ID is nil"))
	}

	fmt.Println("DEBUG: Checking amount - value:", data.Amount)
	if data.Amount == 0 {
		return nil, endTx(eris.New("payment amount cannot be zero"))
	}
	fmt.Println("DEBUG: AccountID nil:", data.AccountID == nil, "PaymentTypeID nil:", data.PaymentTypeID == nil)
	if data.AccountID == nil || data.PaymentTypeID == nil {
		return nil, endTx(eris.New("missing required fields: AccountID and PaymentTypeID are required"))
	}
	fmt.Println("DEBUG: Branch nil:", userOrg.Branch == nil, "BranchSetting nil:", userOrg.Branch == nil || userOrg.Branch.BranchSetting == nil)
	if userOrg.Branch == nil || userOrg.Branch.BranchSetting == nil {
		return nil, endTx(eris.New("branch settings missing"))
	}
	cashOnHandAccountID := userOrg.Branch.BranchSetting.CashOnHandAccountID
	fmt.Println("DEBUG: CashOnHandAccountID nil:", cashOnHandAccountID == nil)
	if cashOnHandAccountID == nil {
		return nil, endTx(eris.New("cash on hand account ID is nil"))
	}
	fmt.Println("DEBUG: Checking cash on hand vs data account - match:", cashOnHandAccountID == data.AccountID)
	if cashOnHandAccountID == data.AccountID {
		return nil, endTx(eris.New("cash on hand account ID does not match"))
	}

	fmt.Println("DEBUG: Initializing transaction variables")
	var transaction *types.Transaction
	now := time.Now().UTC()
	timeMachine := userOrg.UserOrgTime()

	fmt.Println("DEBUG: TransactionID nil:", data.TransactionID == nil)
	if data.TransactionID != nil {
		fmt.Println("DEBUG: Getting transaction by ID:", *data.TransactionID)
		transaction, err = core.TransactionManager(service).GetByID(context, *data.TransactionID)
		if errors.Is(err, gorm.ErrRecordNotFound) {
			transaction = nil
		} else if err != nil {
			return nil, endTx(eris.Wrap(err, "failed to retrieve transaction"))
		}
		fmt.Println("DEBUG: Transaction found:", transaction != nil)
	}

	fmt.Println("DEBUG: Initializing memberProfileID")
	var memberProfileID *uuid.UUID
	if transaction != nil {
		memberProfileID = transaction.MemberProfileID
	}

	fmt.Println("DEBUG: MemberProfileID nil:", data.MemberProfileID == nil)
	if data.MemberProfileID != nil {
		fmt.Println("DEBUG: Getting member profile")
		memberProfile, err := core.MemberProfileManager(service).GetByID(context, *data.MemberProfileID)
		fmt.Println("DEBUG: Member profile retrieved - error:", err, "nil:", memberProfile == nil)
		if err != nil || memberProfile == nil {
			return nil, endTx(eris.New("failed to retrieve member profile"))
		}
		memberProfileID = &memberProfile.ID
	}
	fmt.Println("DEBUG: Getting current transaction batch")
	transactionBatch, err := core.TransactionBatchCurrent(context, service, userOrg.UserID, userOrg.OrganizationID, *userOrg.BranchID)
	fmt.Println("DEBUG: Transaction batch result - error:", err, "nil:", transactionBatch == nil)
	if err != nil || transactionBatch == nil {
		return nil, endTx(eris.New("transaction batch error"))
	}
	fmt.Println("DEBUG: Locking account for update - ID:", *data.AccountID)
	account, err := core.AccountLockForUpdate(context, service, tx, *data.AccountID)
	fmt.Println("DEBUG: Account lock result - error:", err, "nil:", account == nil)
	if err != nil {
		return nil, endTx(err)
	}
	fmt.Println("DEBUG: Locking cash on hand account for update")
	cashOnHandAccount, err := core.AccountLockForUpdate(context, service, tx, *cashOnHandAccountID)
	fmt.Println("DEBUG: Cash on hand account lock result - error:", err, "nil:", cashOnHandAccount == nil)
	if err != nil {
		return nil, endTx(err)
	}
	fmt.Println("DEBUG: Getting payment type")
	paymentType, err := core.PaymentTypeManager(service).GetByID(context, *data.PaymentTypeID)
	fmt.Println("DEBUG: Payment type result - error:", err, "nil:", paymentType == nil)
	if err != nil || paymentType == nil {
		return nil, endTx(eris.New("payment type is nil"))
	}
	fmt.Println("DEBUG: Transaction is nil:", transaction == nil)
	if transaction == nil {
		fmt.Println("DEBUG: Creating new transaction")
		transaction = &types.Transaction{
			CreatedAt:            now,
			CreatedByID:          userOrg.UserID,
			UpdatedAt:            now,
			UpdatedByID:          userOrg.UserID,
			BranchID:             *userOrg.BranchID,
			OrganizationID:       userOrg.OrganizationID,
			SignatureMediaID:     data.SignatureMediaID,
			TransactionBatchID:   &transactionBatch.ID,
			EmployeeUserID:       &userOrg.UserID,
			MemberProfileID:      memberProfileID,
			MemberJointAccountID: data.MemberJointAccountID,
			ReferenceNumber:      data.ReferenceNumber,
			Description:          data.Description,
			Amount:               0,
			CurrencyID:           *account.CurrencyID,
		}
		if err := core.TransactionManager(service).CreateWithTx(context, tx, transaction); err != nil {
			return nil, endTx(err)
		}
	}

	fmt.Println("DEBUG: Processing source:", data.Source)
	var credit, debit float64
	switch data.Source {
	case types.GeneralLedgerSourcePayment, types.GeneralLedgerSourceDeposit:
		fmt.Println("DEBUG: Payment/Deposit source - reverse:", data.Reverse)
		if data.Reverse {
			credit, debit, err = usecase.Withdraw(account, data.Amount)
		} else {
			credit, debit, err = usecase.Deposit(account, data.Amount)
		}
	case types.GeneralLedgerSourceWithdraw:
		fmt.Println("DEBUG: Withdraw source - reverse:", data.Reverse)
		if data.Reverse {
			credit, debit, err = usecase.Deposit(account, data.Amount)
		} else {
			credit, debit, err = usecase.Withdraw(account, data.Amount)
		}
	default:
		fmt.Println("DEBUG: Unsupported source type:", data.Source)
		err = eris.New("unsupported source type")
	}

	fmt.Println("DEBUG: Credit/Debit calculation - credit:", credit, "debit:", debit, "error:", err)
	if err != nil {
		return nil, endTx(err)
	}

	fmt.Println("DEBUG: LoanTransactionID nil:", data.LoanTransactionID == nil)
	if data.LoanTransactionID != nil {
		fmt.Println("DEBUG: Getting loan account by loan transaction")
		loanAccount, err := core.GetLoanAccountByLoanTransaction(context, service, tx, *data.LoanTransactionID, account.ID, userOrg.OrganizationID, *userOrg.BranchID)
		fmt.Println("DEBUG: Loan account retrieved - error:", err, "nil:", loanAccount == nil)
		if err == nil && loanAccount != nil {
			fmt.Println("DEBUG: Updating loan account statistics")
			creditDec := decimal.NewFromFloat(credit)
			debitDec := decimal.NewFromFloat(debit)
			if creditDec.GreaterThan(decimal.Zero) {
				loanAccount.TotalPaymentCount += 1
				loanAccount.TotalPayment = decimal.NewFromFloat(loanAccount.TotalPayment).Add(creditDec).InexactFloat64()
			}
			if debitDec.GreaterThan(decimal.Zero) {
				loanAccount.TotalDeductionCount += 1
				loanAccount.TotalDeduction = decimal.NewFromFloat(loanAccount.TotalDeduction).Add(debitDec).InexactFloat64()
			}
			fmt.Println("DEBUG: Updating loan account with tx")
			if err := core.LoanAccountManager(service).UpdateByIDWithTx(context, tx, loanAccount.ID, loanAccount); err != nil {
				return nil, endTx(err)
			}
		}
	}
	fmt.Println("DEBUG: Creating new general ledger entry")
	newGeneralLedger := &types.GeneralLedger{
		CreatedAt:          now,
		CreatedByID:        userOrg.UserID,
		UpdatedAt:          now,
		UpdatedByID:        userOrg.UserID,
		BranchID:           *userOrg.BranchID,
		OrganizationID:     userOrg.OrganizationID,
		TransactionBatchID: &transactionBatch.ID,
		ReferenceNumber:    transaction.ReferenceNumber,
		TransactionID:      &transaction.ID,
		EntryDate:          timeMachine,
		AccountID:          data.AccountID,
		PaymentTypeID:      &paymentType.ID,
		Source:             data.Source,
		Credit:             credit,
		Debit:              debit,
		CurrencyID:         account.CurrencyID,
		Account:            account,
		MemberProfileID:    memberProfileID,
		EmployeeUserID:     &userOrg.UserID,
	}
	fmt.Println("DEBUG: Creating general ledger entry")
	if err := core.CreateGeneralLedgerEntry(context, service, tx, newGeneralLedger); err != nil {
		return nil, endTx(err)
	}
	fmt.Println("DEBUG: Updating transaction amount")
	inputAmount := decimal.NewFromFloat(data.Amount)
	transactionDec := decimal.NewFromFloat(transaction.Amount)
	transactionDec = transactionDec.Add(inputAmount)
	if data.Reverse {
		transactionDec = transactionDec.Mul(decimal.NewFromInt(-1))
	}
	transaction.Amount = transactionDec.InexactFloat64()
	fmt.Println("DEBUG: New transaction amount:", transaction.Amount)

	fmt.Println("DEBUG: Updating transaction with tx")
	if err := core.TransactionManager(service).UpdateByIDWithTx(context, tx, transaction.ID, transaction); err != nil {
		return nil, endTx(err)
	}
	fmt.Println("DEBUG: Creating cash on hand general ledger entry")
	cashOnHandGeneralLedger := &types.GeneralLedger{
		CreatedAt:          now,
		CreatedByID:        userOrg.UserID,
		UpdatedAt:          now,
		UpdatedByID:        userOrg.UserID,
		BranchID:           *userOrg.BranchID,
		OrganizationID:     userOrg.OrganizationID,
		EntryDate:          timeMachine,
		TransactionBatchID: &transactionBatch.ID,
		TransactionID:      &transaction.ID,
		AccountID:          cashOnHandAccountID,
		PaymentTypeID:      &paymentType.ID,
		Credit:             debit,
		Debit:              credit,
		Source:             data.Source,
		CurrencyID:         account.CurrencyID,
		Account:            cashOnHandAccount,
		MemberProfileID:    memberProfileID,
		EmployeeUserID:     &userOrg.UserID,
		ReferenceNumber:    transaction.ReferenceNumber,
	}
	fmt.Println("DEBUG: Creating cash on hand ledger entry")
	if err := core.CreateGeneralLedgerEntry(context, service, tx, cashOnHandGeneralLedger); err != nil {
		return nil, endTx(err)
	}
	fmt.Println("DEBUG: Calling endTx(nil)")
	if err := endTx(nil); err != nil {
		return nil, err
	}
	fmt.Println("DEBUG: Calling TransactionBatchBalancing")
	if err := TransactionBatchBalancing(context, service, &transactionBatch.ID); err != nil {
		return nil, err
	}
	fmt.Println("DEBUG: TransactionPayment completed successfully")
	return newGeneralLedger, nil
}
