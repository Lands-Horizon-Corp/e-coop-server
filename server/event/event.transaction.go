package event

import (
	"context"
	"errors"
	"fmt"
	"time"

	"github.com/Lands-Horizon-Corp/e-coop-server/server/model/core"
	"github.com/Lands-Horizon-Corp/e-coop-server/server/usecase"
	"github.com/google/uuid"
	"github.com/labstack/echo/v4"
	"github.com/rotisserie/eris"
	"github.com/shopspring/decimal"
	"gorm.io/gorm"
)

type TransactionEvent struct {
	Amount               float64    `json:"amount" validate:"required"`
	AccountID            *uuid.UUID `json:"account_id" validate:"required"`
	PaymentTypeID        *uuid.UUID `json:"payment_type_id" validate:"required"`
	TransactionID        *uuid.UUID `json:"transaction_id"`
	MemberProfileID      *uuid.UUID `json:"member_profile_id"`
	SignatureMediaID     *uuid.UUID `json:"signature_media_id"`
	MemberJointAccountID *uuid.UUID `json:"member_joint_account_id"`
	LoanTransactionID    *uuid.UUID `json:"loan_transaction_id"`

	Source core.GeneralLedgerSource `json:"source" validate:"required"`

	EntryDate             *time.Time `json:"entry_date"`
	BankID                *uuid.UUID `json:"bank_id"`
	ProofOfPaymentMediaID *uuid.UUID `json:"proof_of_payment_media_id"`

	ReferenceNumber     string `json:"reference_number" validate:"required"`
	Description         string `json:"description" validate:"required"`
	BankReferenceNumber string `json:"bank_reference_number"`
	ORAutoGenerated     bool   `json:"or_auto_generated"`
	Reverse             bool   `json:"reverse"`
}

func (e *Event) TransactionPayment(
	context context.Context,
	ctx echo.Context,
	tx *gorm.DB,
	endTx func(error) error,
	data TransactionEvent,
) (*core.GeneralLedger, error) {

	startTime := time.Now()
	defer func() {
		duration := time.Since(startTime)
		if duration > 5*time.Second {
			e.Footstep(ctx, FootstepEvent{
				Activity:    "performance-warning",
				Description: fmt.Sprintf("Payment operation took %.2fs - potential performance issue (/transaction/payment/:transaction_id)", duration.Seconds()),
				Module:      "Transaction",
			})
		}
	}()
	block, blocked, err := e.HandleIPBlocker(context, ctx)
	if err != nil {
		return nil, endTx(eris.Wrap(err, "internal error during IP block check"))
	}
	if block == nil {
		return nil, endTx(eris.New("IP blocker function is nil"))
	}
	if blocked {
		return nil, endTx(eris.New("IP is temporarily blocked due to repeated errors"))
	}
	userOrg, err := e.CurrentUserOrganization(context, ctx)
	if err != nil {
		return nil, endTx(eris.Wrap(err, "failed to get user organization"))
	}
	if userOrg == nil {
		return nil, endTx(eris.New("user organization is nil"))
	}
	if userOrg.BranchID == nil {
		return nil, endTx(eris.New("user organization branch ID is nil"))
	}
	if data.Amount == 0 {
		return nil, endTx(eris.New("payment amount cannot be zero"))
	}
	if data.AccountID == nil || data.PaymentTypeID == nil {
		return nil, endTx(eris.New("missing required fields: AccountID and PaymentTypeID are required"))
	}
	if userOrg.Branch == nil || userOrg.Branch.BranchSetting == nil {
		return nil, endTx(eris.New("branch settings missing"))
	}
	cashOnHandAccountID := userOrg.Branch.BranchSetting.CashOnHandAccountID
	if cashOnHandAccountID == nil {
		return nil, endTx(eris.New("cash on hand account ID is nil"))
	}
	if cashOnHandAccountID == data.AccountID {
		return nil, endTx(eris.New("cash on hand account ID does not match"))
	}

	var transaction *core.Transaction
	now := time.Now().UTC()
	if data.TransactionID != nil {
		transaction, err = e.core.TransactionManager().GetByID(context, *data.TransactionID)
		if errors.Is(err, gorm.ErrRecordNotFound) {
			transaction = nil
		} else if err != nil {
			return nil, endTx(eris.Wrap(err, "failed to retrieve transaction"))
		}
	}

	var memberProfileID *uuid.UUID
	if transaction != nil {
		memberProfileID = transaction.MemberProfileID
	}
	if data.MemberProfileID != nil {
		memberProfile, err := e.core.MemberProfileManager().GetByID(context, *data.MemberProfileID)
		if err != nil || memberProfile == nil {
			return nil, endTx(eris.New("failed to retrieve member profile"))
		}
		memberProfileID = &memberProfile.ID
	}

	transactionBatch, err := e.core.TransactionBatchCurrent(context, userOrg.UserID, userOrg.OrganizationID, *userOrg.BranchID)
	if err != nil || transactionBatch == nil {
		return nil, endTx(eris.New("transaction batch error"))
	}

	account, err := e.core.AccountLockForUpdate(context, tx, *data.AccountID)
	if err != nil {
		return nil, endTx(err)
	}
	cashOnHandAccount, err := e.core.AccountLockForUpdate(context, tx, *cashOnHandAccountID)
	if err != nil {
		return nil, endTx(err)
	}
	paymentType, err := e.core.PaymentTypeManager().GetByID(context, *data.PaymentTypeID)
	if err != nil || paymentType == nil {
		return nil, endTx(eris.New("payment type is nil"))
	}

	if transaction == nil {
		transaction = &core.Transaction{
			CreatedAt:            now,
			CreatedByID:          userOrg.UserID,
			UpdatedAt:            now,
			UpdatedByID:          userOrg.UserID,
			BranchID:             *userOrg.BranchID,
			OrganizationID:       userOrg.OrganizationID,
			SignatureMediaID:     data.SignatureMediaID,
			TransactionBatchID:   &transactionBatch.ID,
			EmployeeUserID:       &userOrg.UserID,
			MemberProfileID:      memberProfileID,
			MemberJointAccountID: data.MemberJointAccountID,
			ReferenceNumber:      data.ReferenceNumber,
			Description:          data.Description,
			Amount:               0,
			CurrencyID:           *account.CurrencyID,
		}
		if err := e.core.TransactionManager().CreateWithTx(context, tx, transaction); err != nil {
			return nil, endTx(err)
		}
	}

	var credit, debit float64
	switch data.Source {
	case core.GeneralLedgerSourcePayment, core.GeneralLedgerSourceDeposit:
		if data.Reverse {
			credit, debit, err = usecase.Withdraw(context, account, data.Amount)
		} else {
			credit, debit, err = usecase.Deposit(context, account, data.Amount)
		}
	case core.GeneralLedgerSourceWithdraw:
		if data.Reverse {
			credit, debit, err = usecase.Deposit(context, account, data.Amount)
		} else {
			credit, debit, err = usecase.Withdraw(context, account, data.Amount)
		}
	default:
		err = eris.New("unsupported source type")
	}

	if err != nil {
		return nil, endTx(err)
	}

	if data.LoanTransactionID != nil {
		loanAccount, err := e.core.GetLoanAccountByLoanTransaction(context, tx, *data.LoanTransactionID, account.ID, userOrg.OrganizationID, *userOrg.BranchID)
		if err == nil && loanAccount != nil {
			creditDec := decimal.NewFromFloat(credit)
			debitDec := decimal.NewFromFloat(debit)
			if creditDec.GreaterThan(decimal.Zero) {
				loanAccount.TotalPaymentCount += 1
				loanAccount.TotalPayment = decimal.NewFromFloat(loanAccount.TotalPayment).Add(creditDec).InexactFloat64()
			}
			if debitDec.GreaterThan(decimal.Zero) {
				loanAccount.TotalDeductionCount += 1
				loanAccount.TotalDeduction = decimal.NewFromFloat(loanAccount.TotalDeduction).Add(debitDec).InexactFloat64()
			}
			e.core.LoanAccountManager().UpdateByIDWithTx(context, tx, loanAccount.ID, loanAccount)
		}
	}
	newGeneralLedger := &core.GeneralLedger{
		CreatedAt:          now,
		CreatedByID:        userOrg.UserID,
		UpdatedAt:          now,
		UpdatedByID:        userOrg.UserID,
		BranchID:           *userOrg.BranchID,
		OrganizationID:     userOrg.OrganizationID,
		TransactionBatchID: &transactionBatch.ID,
		ReferenceNumber:    transaction.ReferenceNumber,
		TransactionID:      &transaction.ID,
		EntryDate:          now,
		AccountID:          data.AccountID,
		PaymentTypeID:      &paymentType.ID,
		Source:             data.Source,
		Credit:             credit,
		Debit:              debit,
		CurrencyID:         account.CurrencyID,
		Account:            account,
		MemberProfileID:    memberProfileID,
		EmployeeUserID:     &userOrg.UserID,
	}
	if err := e.core.CreateGeneralLedgerEntry(context, tx, newGeneralLedger); err != nil {
		return nil, endTx(err)
	}
	amountDec := decimal.NewFromFloat(data.Amount).Abs()
	transactionDec := decimal.NewFromFloat(transaction.Amount)
	if !data.Reverse {
		transaction.Amount = transactionDec.Add(amountDec).InexactFloat64()
	} else {
		transaction.Amount = transactionDec.Sub(amountDec).InexactFloat64()
	}

	if err := e.core.TransactionManager().UpdateByIDWithTx(context, tx, transaction.ID, transaction); err != nil {
		return nil, endTx(err)
	}
	cashOnHandGeneralLedger := &core.GeneralLedger{
		CreatedAt:          now,
		CreatedByID:        userOrg.UserID,
		UpdatedAt:          now,
		UpdatedByID:        userOrg.UserID,
		BranchID:           *userOrg.BranchID,
		OrganizationID:     userOrg.OrganizationID,
		EntryDate:          now,
		TransactionBatchID: &transactionBatch.ID,
		TransactionID:      &transaction.ID,
		AccountID:          cashOnHandAccountID,
		PaymentTypeID:      &paymentType.ID,
		Credit:             debit,
		Debit:              credit,
		Source:             data.Source,
		CurrencyID:         account.CurrencyID,
		Account:            cashOnHandAccount,
		MemberProfileID:    memberProfileID,
		EmployeeUserID:     &userOrg.UserID,
		ReferenceNumber:    transaction.ReferenceNumber,
	}
	if err := e.core.CreateGeneralLedgerEntry(context, tx, cashOnHandGeneralLedger); err != nil {
		return nil, endTx(err)
	}
	if err := endTx(nil); err != nil {
		return nil, err
	}
	if err := e.TransactionBatchBalancing(context, &transactionBatch.ID); err != nil {
		return nil, err
	}
	return newGeneralLedger, nil
}
