package event

import (
	"context"
	"errors"
	"fmt"
	"time"

	"github.com/Lands-Horizon-Corp/e-coop-server/server/model/core"
	"github.com/google/uuid"
	"github.com/labstack/echo/v4"
	"github.com/rotisserie/eris"
	"gorm.io/gorm"
)

type TransactionEvent struct {
	Amount               float64    `json:"amount" validate:"required"`
	AccountID            *uuid.UUID `json:"account_id" validate:"required"`
	PaymentTypeID        *uuid.UUID `json:"payment_type_id" validate:"required"`
	TransactionID        *uuid.UUID `json:"transaction_id"`
	MemberProfileID      *uuid.UUID `json:"member_profile_id"`
	SignatureMediaID     *uuid.UUID `json:"signature_media_id"`
	MemberJointAccountID *uuid.UUID `json:"member_joint_account_id"`
	LoanTransactionID    *uuid.UUID `json:"loan_transaction_id"`

	Source core.GeneralLedgerSource `json:"source" validate:"required"`

	EntryDate             *time.Time `json:"entry_date"`
	BankID                *uuid.UUID `json:"bank_id"`
	ProofOfPaymentMediaID *uuid.UUID `json:"proof_of_payment_media_id"`

	ReferenceNumber     string `json:"reference_number" validate:"required"`
	Description         string `json:"description" validate:"required"`
	BankReferenceNumber string `json:"bank_reference_number"`
	ORAutoGenerated     bool   `json:"or_auto_generated"`
	Reverse             bool   `json:"reverse"`
}

// NOTE: This snippet only shows the modified function body with debug prints.
// Make sure to add "fmt" to the file's import list where this function lives.

func (e *Event) TransactionPayment(

	context context.Context,
	ctx echo.Context,
	tx *gorm.DB,
	endTx func(error) error,
	data TransactionEvent,

) (*core.GeneralLedger, error) {
	fmt.Println("[dbg] enter TransactionPayment")
	startTime := time.Now()
	defer func() {
		duration := time.Since(startTime)
		fmt.Printf("[dbg] defer: duration=%v\n", duration)
		if duration > 5*time.Second {
			e.Footstep(ctx, FootstepEvent{
				Activity:    "performance-warning",
				Description: fmt.Sprintf("Payment operation took %.2fs - potential performance issue (/transaction/payment/:transaction_id)", duration.Seconds()),
				Module:      "Transaction",
			})
		}
	}()

	fmt.Println("[dbg] calling HandleIPBlocker")
	block, blocked, err := e.HandleIPBlocker(context, ctx)
	fmt.Printf("[dbg] HandleIPBlocker returned: block=%v, blocked=%v, err=%v\n", block != nil, blocked, err)
	if err != nil {
		fmt.Println("[dbg] error from HandleIPBlocker")
		e.Footstep(ctx, FootstepEvent{
			Activity:    "ip-block-check-error",
			Description: "IP blocker check failed (/transaction/payment/:transaction_id): " + err.Error(),
			Module:      "Transaction",
		})
		return nil, endTx(eris.Wrap(err, "internal error during IP block check"))
	}

	if block == nil {
		return nil, endTx(eris.New("IP blocker function is nil"))
	}

	if blocked {
		e.Footstep(ctx, FootstepEvent{
			Activity:    "ip-blocked",
			Description: "IP is temporarily blocked due to repeated errors (/transaction/payment/:transaction_id)",
			Module:      "Transaction",
		})
		return nil, endTx(eris.New("IP is temporarily blocked due to repeated errors"))
	}

	userOrg, err := e.userOrganizationToken.CurrentUserOrganization(context, ctx)
	if err != nil {
		e.Footstep(ctx, FootstepEvent{
			Activity:    "auth-error",
			Description: "Failed to get user organization (/transaction/payment/:transaction_id): " + err.Error(),
			Module:      "Transaction",
		})
		block("Failed to get user organization: " + err.Error())
		return nil, endTx(eris.Wrap(err, "failed to get user organization"))
	}
	if userOrg == nil {
		e.Footstep(ctx, FootstepEvent{
			Activity:    "auth-error",
			Description: "User organization is nil (/transaction/payment/:transaction_id)",
			Module:      "Transaction",
		})
		block("User organization is nil")
		return nil, endTx(eris.New("user organization is nil"))
	}
	if userOrg.BranchID == nil {
		e.Footstep(ctx, FootstepEvent{
			Activity:    "branch-error",
			Description: "User organization branch ID is nil (/transaction/payment/:transaction_id)",
			Module:      "Transaction",
		})
		block("User organization branch ID is nil")
		return nil, endTx(eris.New("user organization branch ID is nil"))
	}

	if data.Amount == 0 {
		e.Footstep(ctx, FootstepEvent{
			Activity:    "payment-error",
			Description: "Payment amount cannot be zero (/transaction/payment/:transaction_id)",
			Module:      "Transaction",
		})
		block("Payment amount cannot be zero")
		return nil, endTx(eris.New("payment amount cannot be zero"))
	}
	if data.AccountID == nil || data.PaymentTypeID == nil {
		e.Footstep(ctx, FootstepEvent{
			Activity:    "validation-error",
			Description: "Missing required fields (/transaction/payment/:transaction_id)",
			Module:      "Transaction",
		})
		block("Missing required fields")
		return nil, endTx(eris.New("missing required fields: AccountID and PaymentTypeID are required"))
	}
	cashOnHandAccountID := userOrg.Branch.BranchSetting.CashOnHandAccountID
	if cashOnHandAccountID == nil {
		e.Footstep(ctx, FootstepEvent{
			Activity:    "cash-on-hand-error",
			Description: "Cash on hand account ID is nil (/transaction/payment/:transaction_id)",
			Module:      "Transaction",
		})
		block("Cash on hand account ID is nil")
		return nil, endTx(eris.New("cash on hand account ID is nil"))
	}
	if cashOnHandAccountID == data.AccountID {
		e.Footstep(ctx, FootstepEvent{
			Activity:    "cash-on-hand-mismatch",
			Description: "Cash on hand account ID does not match (/transaction/payment/:transaction_id)",
			Module:      "Transaction",
		})
		block("Cash on hand account ID does not match")
		return nil, endTx(eris.New("cash on hand account ID does not match"))
	}
	var transaction *core.Transaction
	now := time.Now().UTC()
	if data.TransactionID != nil {
		transaction, err = e.core.TransactionManager.GetByID(context, *data.TransactionID)
		if errors.Is(err, gorm.ErrRecordNotFound) {
			transaction = nil
		} else if err != nil {
			e.Footstep(ctx, FootstepEvent{
				Activity:    "transaction-error",
				Description: "Failed to retrieve transaction (/transaction/payment/:transaction_id): " + err.Error(),
				Module:      "Transaction",
			})
			block("Failed to retrieve transaction: " + err.Error())
			return nil, endTx(eris.Wrap(err, "failed to retrieve transaction"))
		}
	}
	var memberProfileID *uuid.UUID
	if transaction != nil {
		memberProfileID = transaction.MemberProfileID
	}
	if data.MemberProfileID != nil {
		memberProfile, err := e.core.MemberProfileManager.GetByID(context, *data.MemberProfileID)
		if err != nil {
			e.Footstep(ctx, FootstepEvent{
				Activity:    "member-error",
				Description: "Failed to retrieve member profile (/transaction/payment/:transaction_id): " + err.Error(),
				Module:      "Transaction",
			})
			block("Failed to retrieve member profile: " + err.Error())
			return nil, endTx(eris.Wrap(err, "failed to retrieve member profile"))
		}
		if memberProfile == nil {
			e.Footstep(ctx, FootstepEvent{
				Activity:    "member-error",
				Description: "Member profile is nil (/transaction/payment/:transaction_id)",
				Module:      "Transaction",
			})
			block("Member profile is nil")
			return nil, endTx(eris.New("member profile is nil"))
		}
		if memberProfile.BranchID != *userOrg.BranchID {
			e.Footstep(ctx, FootstepEvent{
				Activity:    "branch-mismatch",
				Description: "Member does not belong to the current branch (/transaction/payment/:transaction_id)",
				Module:      "Transaction",
			})
			block("Member does not belong to the current branch")
			return nil, endTx(eris.New("member does not belong to the current branch"))
		}
		if memberProfile.OrganizationID != userOrg.OrganizationID {
			e.Footstep(ctx, FootstepEvent{
				Activity:    "organization-mismatch",
				Description: "Member does not belong to the current organization (/transaction/payment/:transaction_id)",
				Module:      "Transaction",
			})
			block("Member does not belong to the current organization")
			return nil, endTx(eris.New("member does not belong to the current organization"))
		}
		memberProfileID = &memberProfile.ID
	}

	transactionBatch, err := e.core.TransactionBatchCurrent(context, userOrg.UserID, userOrg.OrganizationID, *userOrg.BranchID)
	if err != nil {
		e.Footstep(ctx, FootstepEvent{
			Activity:    "batch-error",
			Description: "Failed to retrieve transaction batch (/transaction/payment/:transaction_id): " + err.Error(),
			Module:      "Transaction",
		})
		block("Failed to retrieve transaction batch: " + err.Error())
		return nil, endTx(eris.Wrap(err, "failed to retrieve transaction batch"))
	}
	if transactionBatch == nil {
		e.Footstep(ctx, FootstepEvent{
			Activity:    "batch-error",
			Description: "Transaction batch is nil (/transaction/payment/:transaction_id)",
			Module:      "Transaction",
		})
		block("Transaction batch is nil")
		return nil, endTx(eris.New("transaction batch is nil"))
	}

	account, err := e.core.AccountLockForUpdate(context, tx, *data.AccountID)
	if err != nil {
		e.Footstep(ctx, FootstepEvent{
			Activity:    "account-lock-error",
			Description: "Failed to acquire account lock for concurrent protection (/transaction/payment/:transaction_id): " + err.Error(),
			Module:      "Transaction",
		})
		block("Failed to acquire account lock: " + err.Error())
		return nil, endTx(eris.Wrap(err, "failed to acquire account lock for concurrent protection"))
	}

	if account == nil {
		e.Footstep(ctx, FootstepEvent{
			Activity:    "account-error",
			Description: "Account is nil (/transaction/payment/:transaction_id)",
			Module:      "Transaction",
		})
		block("Account is nil")
		return nil, endTx(eris.New("account is nil"))
	}

	if account.BranchID != *userOrg.BranchID {
		e.Footstep(ctx, FootstepEvent{
			Activity:    "branch-mismatch",
			Description: "Account does not belong to the current branch (/transaction/payment/:transaction_id)",
			Module:      "Transaction",
		})
		block("Account does not belong to the current branch")
		return nil, endTx(eris.New("account does not belong to the current branch"))
	}
	if account.OrganizationID != userOrg.OrganizationID {
		e.Footstep(ctx, FootstepEvent{
			Activity:    "organization-mismatch",
			Description: "Account does not belong to the current organization (/transaction/payment/:transaction_id)",
			Module:      "Transaction",
		})
		block("Account does not belong to the current organization")
		return nil, endTx(eris.New("account does not belong to the current organization"))
	}

	cashOnHandAccount, err := e.core.AccountLockForUpdate(context, tx, *cashOnHandAccountID)
	if err != nil {
		e.Footstep(ctx, FootstepEvent{
			Activity:    "account-lock-error",
			Description: "Failed to acquire account lock for concurrent protection (/transaction/payment/:transaction_id): " + err.Error(),
			Module:      "Transaction",
		})
		block("Failed to acquire account lock: " + err.Error())
		return nil, endTx(eris.Wrap(err, "failed to acquire account lock for concurrent protection for cash on hand account"))
	}
	if cashOnHandAccount == nil {
		e.Footstep(ctx, FootstepEvent{
			Activity:    "account-error",
			Description: "Cash on hand account is nil (/transaction/payment/:transaction_id)",
			Module:      "Transaction",
		})
		block("Cash on hand account is nil")
		return nil, endTx(eris.New("cash on hand account is nil"))
	}

	paymentType, err := e.core.PaymentTypeManager.GetByID(context, *data.PaymentTypeID)
	if err != nil {
		e.Footstep(ctx, FootstepEvent{
			Activity:    "payment-type-error",
			Description: "Failed to retrieve payment type (/transaction/payment/:transaction_id): " + err.Error(),
			Module:      "Transaction",
		})
		block("Failed to retrieve payment type: " + err.Error())
		return nil, endTx(eris.Wrap(err, "failed to retrieve payment type"))
	}
	if paymentType == nil {
		e.Footstep(ctx, FootstepEvent{
			Activity:    "payment-type-error",
			Description: "Payment type is nil (/transaction/payment/:transaction_id)",
			Module:      "Transaction",
		})
		block("Payment type is nil")
		return nil, endTx(eris.New("payment type is nil"))
	}
	if paymentType.OrganizationID != userOrg.OrganizationID {
		e.Footstep(ctx, FootstepEvent{
			Activity:    "organization-mismatch",
			Description: "Payment type does not belong to the current organization (/transaction/payment/:transaction_id)",
			Module:      "Transaction",
		})
		block("Payment type does not belong to the current organization")
		return nil, endTx(eris.New("payment type does not belong to the current organization"))
	}

	if transaction == nil {
		transaction = &core.Transaction{
			CreatedAt:            now,
			CreatedByID:          userOrg.UserID,
			UpdatedAt:            now,
			UpdatedByID:          userOrg.UserID,
			BranchID:             *userOrg.BranchID,
			OrganizationID:       userOrg.OrganizationID,
			SignatureMediaID:     data.SignatureMediaID,
			TransactionBatchID:   &transactionBatch.ID,
			EmployeeUserID:       &userOrg.UserID,
			MemberProfileID:      memberProfileID,
			MemberJointAccountID: data.MemberJointAccountID,
			ReferenceNumber:      data.ReferenceNumber,
			Description:          data.Description,
			Amount:               0,
			LoanBalance:          0,
			LoanDue:              0,
			TotalDue:             0,
			FinesDue:             0,
			TotalLoan:            0,
			InterestDue:          0,
			CurrencyID:           *account.CurrencyID,
		}
		if err := e.core.TransactionManager.CreateWithTx(context, tx, transaction); err != nil {
			e.Footstep(ctx, FootstepEvent{
				Activity:    "transaction-create-error",
				Description: "Failed to create transaction (/transaction/payment/:transaction_id): " + err.Error(),
				Module:      "Transaction",
			})
			return nil, endTx(eris.Wrap(err, "failed to create transaction"))
		}
	}

	referenceNumber := data.ReferenceNumber
	if transaction.ReferenceNumber != "" {
		referenceNumber = transaction.ReferenceNumber
	}
	memberJointAccountID := data.MemberJointAccountID
	if memberJointAccountID == nil {
		memberJointAccountID = transaction.MemberJointAccountID
	}

	if e.usecase == nil {
		e.Footstep(ctx, FootstepEvent{
			Activity:    "service-error",
			Description: "Service is nil (/transaction/payment/:transaction_id)",
			Module:      "Transaction",
		})
		block("Service is nil")
		return nil, endTx(eris.New("service is nil"))
	}

	var credit, debit float64
	switch data.Source {

	case core.GeneralLedgerSourcePayment, core.GeneralLedgerSourceDeposit:
		if data.Reverse {
			credit, debit, err = e.usecase.Withdraw(context, account, data.Amount)
		} else {
			credit, debit, err = e.usecase.Deposit(context, account, data.Amount)
		}

		if err != nil {
			err = eris.Wrap(err, "Account")
		}
	case core.GeneralLedgerSourceWithdraw:
		if data.Reverse {
			credit, debit, err = e.usecase.Deposit(context, account, data.Amount)
			if err != nil {
				err = eris.Wrap(err, "Account")
			}
		} else {
			credit, debit, err = e.usecase.Withdraw(context, account, data.Amount)
			if err != nil {
				err = eris.Wrap(err, "Account")
			}
		}

	default:
		err = eris.New("unsupported source type - Account")
	}
	if err != nil {
		e.Footstep(ctx, FootstepEvent{
			Activity:    "transaction-process-error",
			Description: "Failed to process transaction (/transaction/payment/:transaction_id): " + err.Error(),
			Module:      "Transaction",
		})
		block("Failed to process transaction: " + err.Error())
		return nil, endTx(eris.Wrap(err, "failed to process transaction"))
	}

	loanTransactionID := data.LoanTransactionID
	if loanTransactionID != nil {
		loanAccount, err := e.core.GetLoanAccountByLoanTransaction(
			context,
			tx,
			*loanTransactionID,
			account.ID,
			userOrg.OrganizationID,
			*userOrg.BranchID,
		)
		if err != nil {
			e.Footstep(ctx, FootstepEvent{
				Activity:    "loan-account-retrieval-failed",
				Description: "Failed to retrieve loan account for loan transaction " + loanTransactionID.String() + ": " + err.Error(),
				Module:      "Transaction",
			})
			return nil, endTx(eris.Wrap(err, "failed to retrieve loan account"))
		}

		if loanAccount != nil {
			if credit > 0 {
				loanAccount.TotalPaymentCount += 1
				loanAccount.TotalPayment = e.provider.Service.Decimal.Add(
					loanAccount.TotalPayment, credit)
			}

			if debit > 0 {
				loanAccount.TotalDeductionCount += 1
				loanAccount.TotalDeduction = e.provider.Service.Decimal.Add(
					loanAccount.TotalDeduction, debit)
			}
			loanAccount.UpdatedByID = userOrg.UserID
			loanAccount.UpdatedAt = now

			if err := e.core.LoanAccountManager.UpdateByIDWithTx(context, tx, loanAccount.ID, loanAccount); err != nil {
				e.Footstep(ctx, FootstepEvent{
					Activity: "loan-account-update-failed",
					Description: "Failed to update loan account " +
						loanAccount.ID.String() + ": " + err.Error(),
					Module: "Transaction",
				})
				return nil, endTx(eris.Wrap(err, "failed to update loan account"))
			}

		}
	}

	userOrgTime := userOrg.UserOrgTime()
	if data.EntryDate != nil {
		userOrgTime = *data.EntryDate

	}
	newGeneralLedger := &core.GeneralLedger{
		CreatedAt:                  now,
		CreatedByID:                userOrg.UserID,
		UpdatedAt:                  now,
		UpdatedByID:                userOrg.UserID,
		BranchID:                   *userOrg.BranchID,
		OrganizationID:             userOrg.OrganizationID,
		TransactionBatchID:         &transactionBatch.ID,
		ReferenceNumber:            referenceNumber,
		TransactionID:              &transaction.ID,
		EntryDate:                  userOrgTime,
		SignatureMediaID:           data.SignatureMediaID,
		ProofOfPaymentMediaID:      data.ProofOfPaymentMediaID,
		BankID:                     data.BankID,
		AccountID:                  data.AccountID,
		MemberProfileID:            memberProfileID,
		MemberJointAccountID:       memberJointAccountID,
		PaymentTypeID:              &paymentType.ID,
		TransactionReferenceNumber: data.ReferenceNumber,
		Source:                     data.Source,
		BankReferenceNumber:        data.BankReferenceNumber,
		EmployeeUserID:             &userOrg.UserID,
		Description:                data.Description,
		TypeOfPaymentType:          paymentType.Type,
		Credit:                     credit,
		Debit:                      debit,
		CurrencyID:                 account.CurrencyID,
		LoanTransactionID:          loanTransactionID,

		Account: account,
	}
	if err := e.core.CreateGeneralLedgerEntry(context, tx, newGeneralLedger); err != nil {

		e.Footstep(ctx, FootstepEvent{
			Activity:    "ledger-create-error",
			Description: "Failed to create general ledger entry (/transaction/payment/:transaction_id): " + err.Error(),
			Module:      "Transaction",
		})
		return nil, endTx(eris.Wrap(err, "failed to create general ledger entry"))
	}
	switch data.Source {
	case core.GeneralLedgerSourcePayment, core.GeneralLedgerSourceDeposit:
		if data.Reverse {
			if data.Amount < 0 {
				absoluteAmount := e.provider.Service.Decimal.Abs(data.Amount)
				transaction.Amount = e.provider.Service.Decimal.Add(transaction.Amount, absoluteAmount)
			} else {
				absoluteAmount := e.provider.Service.Decimal.Abs(data.Amount)
				transaction.Amount = e.provider.Service.Decimal.Subtract(transaction.Amount, absoluteAmount)
			}
		} else {
			if data.Amount < 0 {
				absoluteAmount := e.provider.Service.Decimal.Abs(data.Amount)
				transaction.Amount = e.provider.Service.Decimal.Subtract(transaction.Amount, absoluteAmount)
			} else {
				absoluteAmount := e.provider.Service.Decimal.Abs(data.Amount)
				transaction.Amount = e.provider.Service.Decimal.Add(transaction.Amount, absoluteAmount)
			}
		}
	case core.GeneralLedgerSourceWithdraw:
		if data.Reverse {
			if data.Amount < 0 {
				absoluteAmount := e.provider.Service.Decimal.Abs(data.Amount)
				transaction.Amount = e.provider.Service.Decimal.Subtract(transaction.Amount, absoluteAmount)
			} else {
				absoluteAmount := e.provider.Service.Decimal.Abs(data.Amount)
				transaction.Amount = e.provider.Service.Decimal.Add(transaction.Amount, absoluteAmount)
			}
		} else {
			if data.Amount < 0 {
				absoluteAmount := e.provider.Service.Decimal.Abs(data.Amount)
				transaction.Amount = e.provider.Service.Decimal.Add(transaction.Amount, absoluteAmount)
			} else {
				absoluteAmount := e.provider.Service.Decimal.Abs(data.Amount)
				transaction.Amount = e.provider.Service.Decimal.Subtract(transaction.Amount, absoluteAmount)
			}
		}
	}

	transaction.UpdatedAt = now
	transaction.UpdatedByID = userOrg.UserID
	if err := e.core.TransactionManager.UpdateByIDWithTx(context, tx, transaction.ID, transaction); err != nil {
		e.Footstep(ctx, FootstepEvent{
			Activity:    "transaction-update-error",
			Description: "Failed to update transaction (/transaction/payment/:transaction_id): " + err.Error(),
			Module:      "Transaction",
		})
		block("Failed to update transaction: " + err.Error())
		return nil, endTx(eris.Wrap(err, "failed to update transaction"))
	}
	cashOnHandGeneralLedger := &core.GeneralLedger{
		CreatedAt:                  now,
		CreatedByID:                userOrg.UserID,
		UpdatedAt:                  now,
		UpdatedByID:                userOrg.UserID,
		BranchID:                   *userOrg.BranchID,
		OrganizationID:             userOrg.OrganizationID,
		TransactionBatchID:         &transactionBatch.ID,
		ReferenceNumber:            referenceNumber,
		TransactionID:              &transaction.ID,
		EntryDate:                  userOrgTime,
		SignatureMediaID:           data.SignatureMediaID,
		ProofOfPaymentMediaID:      data.ProofOfPaymentMediaID,
		BankID:                     data.BankID,
		AccountID:                  cashOnHandAccountID,
		MemberProfileID:            memberProfileID,
		MemberJointAccountID:       memberJointAccountID,
		PaymentTypeID:              &paymentType.ID,
		TransactionReferenceNumber: data.ReferenceNumber,
		Source:                     data.Source,
		BankReferenceNumber:        data.BankReferenceNumber,
		EmployeeUserID:             &userOrg.UserID,
		Description:                data.Description,
		TypeOfPaymentType:          paymentType.Type,
		Credit:                     debit,
		Debit:                      credit,
		CurrencyID:                 account.CurrencyID,
		Account:                    cashOnHandAccount,
	}
	if err := e.core.CreateGeneralLedgerEntry(context, tx, cashOnHandGeneralLedger); err != nil {
		e.Footstep(ctx, FootstepEvent{
			Activity:    "ledger-create-error",
			Description: "Failed to create general ledger entry (/transaction/payment/:transaction_id): " + err.Error(),
			Module:      "Transaction",
		})
		block("Failed to create general ledger entry for cash on hand: " + err.Error())
		return nil, endTx(eris.Wrap(err, "failed to create general ledger entry for cash on hand"))
	}
	if err := e.TransactionBatchBalancing(context, &transactionBatch.ID); err != nil {
		return nil, endTx(eris.Wrap(err, "failed to balance transaction batch"))
	}
	if err := endTx(nil); err != nil {
		e.Footstep(ctx, FootstepEvent{
			Activity:    "db-commit-error",
			Description: "Failed to commit transaction (/transaction/payment/:transaction_id): " + err.Error(),
			Module:      "Transaction",
		})
		return nil, endTx(eris.Wrap(err, "failed to commit transaction"))
	}

	duration := time.Since(startTime)
	e.Footstep(ctx, FootstepEvent{
		Activity: "payment-success",
		Description: fmt.Sprintf("Payment completed successfully. Amount: %.2f, Account: %s, Duration: %.3fs (/transaction/payment/:transaction_id)",
			data.Amount, data.AccountID.String(), duration.Seconds()),
		Module: "Transaction",
	})

	return newGeneralLedger, nil
}
