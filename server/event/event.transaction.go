package event

import (
	"context"
	"errors"
	"fmt"
	"time"

	"github.com/Lands-Horizon-Corp/e-coop-server/server/model/core"
	"github.com/google/uuid"
	"github.com/labstack/echo/v4"
	"github.com/rotisserie/eris"
	"gorm.io/gorm"
)

type TransactionEvent struct {
	Amount               float64    `json:"amount" validate:"required"`
	AccountID            *uuid.UUID `json:"account_id" validate:"required"`
	PaymentTypeID        *uuid.UUID `json:"payment_type_id" validate:"required"`
	TransactionID        *uuid.UUID `json:"transaction_id"`
	MemberProfileID      *uuid.UUID `json:"member_profile_id"`
	SignatureMediaID     *uuid.UUID `json:"signature_media_id"`
	MemberJointAccountID *uuid.UUID `json:"member_joint_account_id"`
	LoanTransactionID    *uuid.UUID `json:"loan_transaction_id"`

	Source core.GeneralLedgerSource `json:"source" validate:"required"`

	EntryDate             *time.Time `json:"entry_date"`
	BankID                *uuid.UUID `json:"bank_id"`
	ProofOfPaymentMediaID *uuid.UUID `json:"proof_of_payment_media_id"`

	ReferenceNumber     string `json:"reference_number" validate:"required"`
	Description         string `json:"description" validate:"required"`
	BankReferenceNumber string `json:"bank_reference_number"`
	ORAutoGenerated     bool   `json:"or_auto_generated"`
	Reverse             bool   `json:"reverse"`
}

// NOTE: This snippet only shows the modified function body with debug prints.
// Make sure to add "fmt" to the file's import list where this function lives.

func (e *Event) TransactionPayment(

	context context.Context,
	ctx echo.Context,
	tx *gorm.DB,
	endTx func(error) error,
	data TransactionEvent,

) (*core.GeneralLedger, error) {
	fmt.Println("[dbg] enter TransactionPayment")
	startTime := time.Now()
	defer func() {
		duration := time.Since(startTime)
		fmt.Printf("[dbg] defer: duration=%v\n", duration)
		if duration > 5*time.Second {
			e.Footstep(ctx, FootstepEvent{
				Activity:    "performance-warning",
				Description: fmt.Sprintf("Payment operation took %.2fs - potential performance issue (/transaction/payment/:transaction_id)", duration.Seconds()),
				Module:      "Transaction",
			})
		}
	}()

	fmt.Println("[dbg] calling HandleIPBlocker")
	block, blocked, err := e.HandleIPBlocker(context, ctx)
	fmt.Printf("[dbg] HandleIPBlocker returned: block=%v, blocked=%v, err=%v\n", block != nil, blocked, err)
	if err != nil {
		fmt.Println("[dbg] error from HandleIPBlocker")
		e.Footstep(ctx, FootstepEvent{
			Activity:    "ip-block-check-error",
			Description: "IP blocker check failed (/transaction/payment/:transaction_id): " + err.Error(),
			Module:      "Transaction",
		})
		return nil, endTx(eris.Wrap(err, "internal error during IP block check"))
	}

	if block == nil {
		fmt.Println("[dbg] block is nil")
		return nil, endTx(eris.New("IP blocker function is nil"))
	}

	if blocked {
		fmt.Println("[dbg] IP is blocked")
		e.Footstep(ctx, FootstepEvent{
			Activity:    "ip-blocked",
			Description: "IP is temporarily blocked due to repeated errors (/transaction/payment/:transaction_id)",
			Module:      "Transaction",
		})
		return nil, endTx(eris.New("IP is temporarily blocked due to repeated errors"))
	}

	fmt.Println("[dbg] fetching current user organization")
	userOrg, err := e.userOrganizationToken.CurrentUserOrganization(context, ctx)
	fmt.Printf("[dbg] CurrentUserOrganization returned: userOrg=%v, err=%v\n", userOrg != nil, err)
	if err != nil {
		fmt.Println("[dbg] error getting user organization")
		e.Footstep(ctx, FootstepEvent{
			Activity:    "auth-error",
			Description: "Failed to get user organization (/transaction/payment/:transaction_id): " + err.Error(),
			Module:      "Transaction",
		})
		block("Failed to get user organization: " + err.Error())
		return nil, endTx(eris.Wrap(err, "failed to get user organization"))
	}
	if userOrg == nil {
		fmt.Println("[dbg] userOrg is nil")
		e.Footstep(ctx, FootstepEvent{
			Activity:    "auth-error",
			Description: "User organization is nil (/transaction/payment/:transaction_id)",
			Module:      "Transaction",
		})
		block("User organization is nil")
		return nil, endTx(eris.New("user organization is nil"))
	}
	fmt.Printf("[dbg] userOrg.BranchID=%v\n", userOrg.BranchID)
	if userOrg.BranchID == nil {
		fmt.Println("[dbg] userOrg.BranchID is nil")
		e.Footstep(ctx, FootstepEvent{
			Activity:    "branch-error",
			Description: "User organization branch ID is nil (/transaction/payment/:transaction_id)",
			Module:      "Transaction",
		})
		block("User organization branch ID is nil")
		return nil, endTx(eris.New("user organization branch ID is nil"))
	}

	fmt.Printf("[dbg] data.Amount=%v\n", data.Amount)
	if data.Amount == 0 {
		fmt.Println("[dbg] Amount is zero")
		e.Footstep(ctx, FootstepEvent{
			Activity:    "payment-error",
			Description: "Payment amount cannot be zero (/transaction/payment/:transaction_id)",
			Module:      "Transaction",
		})
		block("Payment amount cannot be zero")
		return nil, endTx(eris.New("payment amount cannot be zero"))
	}
	fmt.Printf("[dbg] data.AccountID=%v data.PaymentTypeID=%v\n", data.AccountID, data.PaymentTypeID)
	if data.AccountID == nil || data.PaymentTypeID == nil {
		fmt.Println("[dbg] Missing AccountID or PaymentTypeID")
		e.Footstep(ctx, FootstepEvent{
			Activity:    "validation-error",
			Description: "Missing required fields (/transaction/payment/:transaction_id)",
			Module:      "Transaction",
		})
		block("Missing required fields")
		return nil, endTx(eris.New("missing required fields: AccountID and PaymentTypeID are required"))
	}
	cashOnHandAccountID := userOrg.Branch.BranchSetting.CashOnHandAccountID
	fmt.Printf("[dbg] cashOnHandAccountID=%v\n", cashOnHandAccountID)
	if cashOnHandAccountID == nil {
		fmt.Println("[dbg] cashOnHandAccountID is nil")
		e.Footstep(ctx, FootstepEvent{
			Activity:    "cash-on-hand-error",
			Description: "Cash on hand account ID is nil (/transaction/payment/:transaction_id)",
			Module:      "Transaction",
		})
		block("Cash on hand account ID is nil")
		return nil, endTx(eris.New("cash on hand account ID is nil"))
	}
	if cashOnHandAccountID == data.AccountID {
		fmt.Println("[dbg] cashOnHandAccountID equals data.AccountID (mismatch condition)")
		e.Footstep(ctx, FootstepEvent{
			Activity:    "cash-on-hand-mismatch",
			Description: "Cash on hand account ID does not match (/transaction/payment/:transaction_id)",
			Module:      "Transaction",
		})
		block("Cash on hand account ID does not match")
		return nil, endTx(eris.New("cash on hand account ID does not match"))
	}
	var transaction *core.Transaction
	now := time.Now().UTC()
	if data.TransactionID != nil {
		fmt.Printf("[dbg] retrieving transaction by id: %v\n", *data.TransactionID)
		transaction, err = e.core.TransactionManager.GetByID(context, *data.TransactionID)
		fmt.Printf("[dbg] GetByID transaction returned: transaction=%v, err=%v\n", transaction != nil, err)
		if errors.Is(err, gorm.ErrRecordNotFound) {
			fmt.Println("[dbg] transaction not found (record not found)")
			transaction = nil
		} else if err != nil {
			fmt.Println("[dbg] error retrieving transaction")
			e.Footstep(ctx, FootstepEvent{
				Activity:    "transaction-error",
				Description: "Failed to retrieve transaction (/transaction/payment/:transaction_id): " + err.Error(),
				Module:      "Transaction",
			})
			block("Failed to retrieve transaction: " + err.Error())
			return nil, endTx(eris.Wrap(err, "failed to retrieve transaction"))
		}
	}
	var memberProfileID *uuid.UUID
	if transaction != nil {
		memberProfileID = transaction.MemberProfileID
		fmt.Printf("[dbg] transaction exists: ID=%v memberProfileID=%v\n", transaction.ID, memberProfileID)
	} else {
		fmt.Println("[dbg] no existing transaction, will create new one later")
	}

	if data.MemberProfileID != nil {
		fmt.Printf("[dbg] retrieving member profile by id: %v\n", *data.MemberProfileID)
		memberProfile, err := e.core.MemberProfileManager.GetByID(context, *data.MemberProfileID)
		fmt.Printf("[dbg] GetByID memberProfile returned: memberProfile=%v err=%v\n", memberProfile != nil, err)
		if err != nil {
			fmt.Println("[dbg] error retrieving member profile")
			e.Footstep(ctx, FootstepEvent{
				Activity:    "member-error",
				Description: "Failed to retrieve member profile (/transaction/payment/:transaction_id): " + err.Error(),
				Module:      "Transaction",
			})
			block("Failed to retrieve member profile: " + err.Error())
			return nil, endTx(eris.Wrap(err, "failed to retrieve member profile"))
		}
		if memberProfile == nil {
			fmt.Println("[dbg] member profile is nil")
			e.Footstep(ctx, FootstepEvent{
				Activity:    "member-error",
				Description: "Member profile is nil (/transaction/payment/:transaction_id)",
				Module:      "Transaction",
			})
			block("Member profile is nil")
			return nil, endTx(eris.New("member profile is nil"))
		}
		fmt.Printf("[dbg] memberProfile.BranchID=%v userOrg.BranchID=%v\n", memberProfile.BranchID, *userOrg.BranchID)
		if memberProfile.BranchID != *userOrg.BranchID {
			fmt.Println("[dbg] member branch mismatch")
			e.Footstep(ctx, FootstepEvent{
				Activity:    "branch-mismatch",
				Description: "Member does not belong to the current branch (/transaction/payment/:transaction_id)",
				Module:      "Transaction",
			})
			block("Member does not belong to the current branch")
			return nil, endTx(eris.New("member does not belong to the current branch"))
		}
		fmt.Printf("[dbg] memberProfile.OrganizationID=%v userOrg.OrganizationID=%v\n", memberProfile.OrganizationID, userOrg.OrganizationID)
		if memberProfile.OrganizationID != userOrg.OrganizationID {
			fmt.Println("[dbg] member organization mismatch")
			e.Footstep(ctx, FootstepEvent{
				Activity:    "organization-mismatch",
				Description: "Member does not belong to the current organization (/transaction/payment/:transaction_id)",
				Module:      "Transaction",
			})
			block("Member does not belong to the current organization")
			return nil, endTx(eris.New("member does not belong to the current organization"))
		}
		memberProfileID = &memberProfile.ID
		fmt.Printf("[dbg] memberProfileID set to %v\n", memberProfileID)
	}

	fmt.Println("[dbg] retrieving current transaction batch")
	transactionBatch, err := e.core.TransactionBatchCurrent(context, userOrg.UserID, userOrg.OrganizationID, *userOrg.BranchID)
	fmt.Printf("[dbg] TransactionBatchCurrent returned: txBatch=%v err=%v\n", transactionBatch != nil, err)
	if err != nil {
		fmt.Println("[dbg] error retrieving transaction batch")
		e.Footstep(ctx, FootstepEvent{
			Activity:    "batch-error",
			Description: "Failed to retrieve transaction batch (/transaction/payment/:transaction_id): " + err.Error(),
			Module:      "Transaction",
		})
		block("Failed to retrieve transaction batch: " + err.Error())
		return nil, endTx(eris.Wrap(err, "failed to retrieve transaction batch"))
	}
	if transactionBatch == nil {
		fmt.Println("[dbg] transactionBatch is nil")
		e.Footstep(ctx, FootstepEvent{
			Activity:    "batch-error",
			Description: "Transaction batch is nil (/transaction/payment/:transaction_id)",
			Module:      "Transaction",
		})
		block("Transaction batch is nil")
		return nil, endTx(eris.New("transaction batch is nil"))
	}

	fmt.Printf("[dbg] acquiring account lock for accountID=%v\n", *data.AccountID)
	account, err := e.core.AccountLockForUpdate(context, tx, *data.AccountID)
	fmt.Printf("[dbg] AccountLockForUpdate returned: account=%v err=%v\n", account != nil, err)
	if err != nil {
		fmt.Println("[dbg] error acquiring account lock")
		e.Footstep(ctx, FootstepEvent{
			Activity:    "account-lock-error",
			Description: "Failed to acquire account lock for concurrent protection (/transaction/payment/:transaction_id): " + err.Error(),
			Module:      "Transaction",
		})
		block("Failed to acquire account lock: " + err.Error())
		return nil, endTx(eris.Wrap(err, "failed to acquire account lock for concurrent protection"))
	}

	if account == nil {
		fmt.Println("[dbg] account is nil")
		e.Footstep(ctx, FootstepEvent{
			Activity:    "account-error",
			Description: "Account is nil (/transaction/payment/:transaction_id)",
			Module:      "Transaction",
		})
		block("Account is nil")
		return nil, endTx(eris.New("account is nil"))
	}

	fmt.Printf("[dbg] account.BranchID=%v userOrg.BranchID=%v\n", account.BranchID, *userOrg.BranchID)
	if account.BranchID != *userOrg.BranchID {
		fmt.Println("[dbg] account branch mismatch")
		e.Footstep(ctx, FootstepEvent{
			Activity:    "branch-mismatch",
			Description: "Account does not belong to the current branch (/transaction/payment/:transaction_id)",
			Module:      "Transaction",
		})
		block("Account does not belong to the current branch")
		return nil, endTx(eris.New("account does not belong to the current branch"))
	}
	fmt.Printf("[dbg] account.OrganizationID=%v userOrg.OrganizationID=%v\n", account.OrganizationID, userOrg.OrganizationID)
	if account.OrganizationID != userOrg.OrganizationID {
		fmt.Println("[dbg] account organization mismatch")
		e.Footstep(ctx, FootstepEvent{
			Activity:    "organization-mismatch",
			Description: "Account does not belong to the current organization (/transaction/payment/:transaction_id)",
			Module:      "Transaction",
		})
		block("Account does not belong to the current organization")
		return nil, endTx(eris.New("account does not belong to the current organization"))
	}

	fmt.Printf("[dbg] acquiring cashOnHand account lock for accountID=%v\n", *cashOnHandAccountID)
	cashOnHandAccount, err := e.core.AccountLockForUpdate(context, tx, *cashOnHandAccountID)
	fmt.Printf("[dbg] cashOnHand AccountLockForUpdate returned: account=%v err=%v\n", cashOnHandAccount != nil, err)
	if err != nil {
		fmt.Println("[dbg] error acquiring cashOnHand account lock")
		e.Footstep(ctx, FootstepEvent{
			Activity:    "account-lock-error",
			Description: "Failed to acquire account lock for concurrent protection (/transaction/payment/:transaction_id): " + err.Error(),
			Module:      "Transaction",
		})
		block("Failed to acquire account lock: " + err.Error())
		return nil, endTx(eris.Wrap(err, "failed to acquire account lock for concurrent protection for cash on hand account"))
	}
	if cashOnHandAccount == nil {
		fmt.Println("[dbg] cashOnHandAccount is nil")
		e.Footstep(ctx, FootstepEvent{
			Activity:    "account-error",
			Description: "Cash on hand account is nil (/transaction/payment/:transaction_id)",
			Module:      "Transaction",
		})
		block("Cash on hand account is nil")
		return nil, endTx(eris.New("cash on hand account is nil"))
	}

	fmt.Printf("[dbg] retrieving paymentType by id: %v\n", *data.PaymentTypeID)
	paymentType, err := e.core.PaymentTypeManager.GetByID(context, *data.PaymentTypeID)
	fmt.Printf("[dbg] PaymentTypeManager.GetByID returned: paymentType=%v err=%v\n", paymentType != nil, err)
	if err != nil {
		fmt.Println("[dbg] error retrieving payment type")
		e.Footstep(ctx, FootstepEvent{
			Activity:    "payment-type-error",
			Description: "Failed to retrieve payment type (/transaction/payment/:transaction_id): " + err.Error(),
			Module:      "Transaction",
		})
		block("Failed to retrieve payment type: " + err.Error())
		return nil, endTx(eris.Wrap(err, "failed to retrieve payment type"))
	}
	if paymentType == nil {
		fmt.Println("[dbg] paymentType is nil")
		e.Footstep(ctx, FootstepEvent{
			Activity:    "payment-type-error",
			Description: "Payment type is nil (/transaction/payment/:transaction_id)",
			Module:      "Transaction",
		})
		block("Payment type is nil")
		return nil, endTx(eris.New("payment type is nil"))
	}
	fmt.Printf("[dbg] paymentType.OrganizationID=%v userOrg.OrganizationID=%v\n", paymentType.OrganizationID, userOrg.OrganizationID)
	if paymentType.OrganizationID != userOrg.OrganizationID {
		fmt.Println("[dbg] paymentType organization mismatch")
		e.Footstep(ctx, FootstepEvent{
			Activity:    "organization-mismatch",
			Description: "Payment type does not belong to the current organization (/transaction/payment/:transaction_id)",
			Module:      "Transaction",
		})
		block("Payment type does not belong to the current organization")
		return nil, endTx(eris.New("payment type does not belong to the current organization"))
	}

	if transaction == nil {
		fmt.Println("[dbg] creating new transaction")
		transaction = &core.Transaction{
			CreatedAt:            now,
			CreatedByID:          userOrg.UserID,
			UpdatedAt:            now,
			UpdatedByID:          userOrg.UserID,
			BranchID:             *userOrg.BranchID,
			OrganizationID:       userOrg.OrganizationID,
			SignatureMediaID:     data.SignatureMediaID,
			TransactionBatchID:   &transactionBatch.ID,
			EmployeeUserID:       &userOrg.UserID,
			MemberProfileID:      memberProfileID,
			MemberJointAccountID: data.MemberJointAccountID,
			ReferenceNumber:      data.ReferenceNumber,
			Description:          data.Description,
			Amount:               0,
			LoanBalance:          0,
			LoanDue:              0,
			TotalDue:             0,
			FinesDue:             0,
			TotalLoan:            0,
			InterestDue:          0,
			CurrencyID:           *account.CurrencyID,
		}
		if err := e.core.TransactionManager.CreateWithTx(context, tx, transaction); err != nil {
			fmt.Println("[dbg] error creating transaction")
			e.Footstep(ctx, FootstepEvent{
				Activity:    "transaction-create-error",
				Description: "Failed to create transaction (/transaction/payment/:transaction_id): " + err.Error(),
				Module:      "Transaction",
			})
			block("Failed to create transaction: " + err.Error())
			return nil, endTx(eris.Wrap(err, "failed to create transaction"))
		}
		fmt.Printf("[dbg] created transaction: ID=%v\n", transaction.ID)
	} else {
		fmt.Printf("[dbg] using existing transaction: ID=%v\n", transaction.ID)
	}

	referenceNumber := data.ReferenceNumber
	if transaction.ReferenceNumber != "" {
		referenceNumber = transaction.ReferenceNumber
	}
	memberJointAccountID := data.MemberJointAccountID
	if memberJointAccountID == nil {
		memberJointAccountID = transaction.MemberJointAccountID
	}
	fmt.Printf("[dbg] referenceNumber=%v memberJointAccountID=%v\n", referenceNumber, memberJointAccountID)

	if e.usecase == nil {
		fmt.Println("[dbg] usecase is nil")
		e.Footstep(ctx, FootstepEvent{
			Activity:    "service-error",
			Description: "Service is nil (/transaction/payment/:transaction_id)",
			Module:      "Transaction",
		})
		block("Service is nil")
		return nil, endTx(eris.New("service is nil"))
	}

	var credit, debit float64
	fmt.Printf("[dbg] processing source=%v reverse=%v amount=%v\n", data.Source, data.Reverse, data.Amount)
	switch data.Source {

	case core.GeneralLedgerSourcePayment, core.GeneralLedgerSourceDeposit:
		if data.Reverse {
			fmt.Println("[dbg] calling usecase.Withdraw (reverse deposit/payment)")
			credit, debit, err = e.usecase.Withdraw(context, account, data.Amount)
		} else {
			fmt.Println("[dbg] calling usecase.Deposit (deposit/payment)")
			credit, debit, err = e.usecase.Deposit(context, account, data.Amount)
		}

		if err != nil {
			err = eris.Wrap(err, "Account")
		}
	case core.GeneralLedgerSourceWithdraw:
		if data.Reverse {
			fmt.Println("[dbg] calling usecase.Deposit (reverse withdraw)")
			credit, debit, err = e.usecase.Deposit(context, account, data.Amount)
			if err != nil {
				err = eris.Wrap(err, "Account")
			}
		} else {
			fmt.Println("[dbg] calling usecase.Withdraw (withdraw)")
			credit, debit, err = e.usecase.Withdraw(context, account, data.Amount)
			if err != nil {
				err = eris.Wrap(err, "Account")
			}
		}

	default:
		fmt.Println("[dbg] unsupported source type")
		err = eris.New("unsupported source type - Account")
	}
	fmt.Printf("[dbg] after process: credit=%v debit=%v err=%v\n", credit, debit, err)
	if err != nil {
		fmt.Println("[dbg] error processing transaction amount")
		e.Footstep(ctx, FootstepEvent{
			Activity:    "transaction-process-error",
			Description: "Failed to process transaction (/transaction/payment/:transaction_id): " + err.Error(),
			Module:      "Transaction",
		})
		block("Failed to process transaction: " + err.Error())
		return nil, endTx(eris.Wrap(err, "failed to process transaction"))
	}

	loanTransactionID := data.LoanTransactionID
	fmt.Printf("[dbg] loanTransactionID=%v\n", loanTransactionID)
	if loanTransactionID != nil {
		fmt.Printf("[dbg] retrieving loan account for loanTransactionID=%v\n", *loanTransactionID)
		loanAccount, err := e.core.GetLoanAccountByLoanTransaction(
			context,
			tx,
			*loanTransactionID,
			account.ID,
			userOrg.OrganizationID,
			*userOrg.BranchID,
		)
		fmt.Printf("[dbg] GetLoanAccountByLoanTransaction returned: loanAccount=%v err=%v\n", loanAccount != nil, err)
		if err != nil {
			fmt.Println("[dbg] error retrieving loan account")
			e.Footstep(ctx, FootstepEvent{
				Activity:    "loan-account-retrieval-failed",
				Description: "Failed to retrieve loan account for loan transaction " + loanTransactionID.String() + ": " + err.Error(),
				Module:      "Transaction",
			})
			return nil, endTx(eris.Wrap(err, "failed to retrieve loan account"))
		}

		if loanAccount != nil {
			fmt.Printf("[dbg] updating loanAccount totals: credit=%v debit=%v\n", credit, debit)
			if credit > 0 {
				loanAccount.TotalPaymentCount += 1
				loanAccount.TotalPayment = e.provider.Service.Decimal.Add(
					loanAccount.TotalPayment, credit)
			}

			if debit > 0 {
				loanAccount.TotalDeductionCount += 1
				loanAccount.TotalDeduction = e.provider.Service.Decimal.Add(
					loanAccount.TotalDeduction, debit)
			}
			loanAccount.UpdatedByID = userOrg.UserID
			loanAccount.UpdatedAt = now

			if err := e.core.LoanAccountManager.UpdateByIDWithTx(context, tx, loanAccount.ID, loanAccount); err != nil {
				fmt.Println("[dbg] error updating loan account")
				e.Footstep(ctx, FootstepEvent{
					Activity: "loan-account-update-failed",
					Description: "Failed to update loan account " +
						loanAccount.ID.String() + ": " + err.Error(),
					Module: "Transaction",
				})
				return nil, endTx(eris.Wrap(err, "failed to update loan account"))
			}
			fmt.Println("[dbg] loanAccount updated")
		} else {
			fmt.Println("[dbg] no loanAccount found")
		}
	}

	userOrgTime := userOrg.UserOrgTime()
	fmt.Printf("[dbg] userOrgTime initial=%v\n", userOrgTime)
	if data.EntryDate != nil {
		userOrgTime = *data.EntryDate
		fmt.Printf("[dbg] EntryDate override userOrgTime=%v\n", userOrgTime)
	}
	newGeneralLedger := &core.GeneralLedger{
		CreatedAt:                  now,
		CreatedByID:                userOrg.UserID,
		UpdatedAt:                  now,
		UpdatedByID:                userOrg.UserID,
		BranchID:                   *userOrg.BranchID,
		OrganizationID:             userOrg.OrganizationID,
		TransactionBatchID:         &transactionBatch.ID,
		ReferenceNumber:            referenceNumber,
		TransactionID:              &transaction.ID,
		EntryDate:                  userOrgTime,
		SignatureMediaID:           data.SignatureMediaID,
		ProofOfPaymentMediaID:      data.ProofOfPaymentMediaID,
		BankID:                     data.BankID,
		AccountID:                  data.AccountID,
		MemberProfileID:            memberProfileID,
		MemberJointAccountID:       memberJointAccountID,
		PaymentTypeID:              &paymentType.ID,
		TransactionReferenceNumber: data.ReferenceNumber,
		Source:                     data.Source,
		BankReferenceNumber:        data.BankReferenceNumber,
		EmployeeUserID:             &userOrg.UserID,
		Description:                data.Description,
		TypeOfPaymentType:          paymentType.Type,
		Credit:                     credit,
		Debit:                      debit,
		CurrencyID:                 account.CurrencyID,
		LoanTransactionID:          loanTransactionID,

		Account: account,
	}
	fmt.Printf("[dbg] creating general ledger entry: %+v\n", newGeneralLedger)
	if err := e.core.CreateGeneralLedgerEntry(context, tx, newGeneralLedger); err != nil {
		fmt.Println("[dbg] error creating general ledger entry")
		e.Footstep(ctx, FootstepEvent{
			Activity:    "ledger-create-error",
			Description: "Failed to create general ledger entry (/transaction/payment/:transaction_id): " + err.Error(),
			Module:      "Transaction",
		})
		block("Failed to create general ledger entry: " + err.Error())
		return nil, endTx(eris.Wrap(err, "failed to create general ledger entry"))
	}
	fmt.Printf("[dbg] general ledger entry created: ID=%v\n", newGeneralLedger.ID)

	fmt.Println("[dbg] adjusting transaction.Amount based on source/reverse/amount")
	switch data.Source {
	case core.GeneralLedgerSourcePayment, core.GeneralLedgerSourceDeposit:
		if data.Reverse {
			if data.Amount < 0 {
				absoluteAmount := e.provider.Service.Decimal.Abs(data.Amount)
				transaction.Amount = e.provider.Service.Decimal.Add(transaction.Amount, absoluteAmount)
				fmt.Printf("[dbg] reverse & negative: add %v -> transaction.Amount=%v\n", absoluteAmount, transaction.Amount)
			} else {
				absoluteAmount := e.provider.Service.Decimal.Abs(data.Amount)
				transaction.Amount = e.provider.Service.Decimal.Subtract(transaction.Amount, absoluteAmount)
				fmt.Printf("[dbg] reverse & positive: subtract %v -> transaction.Amount=%v\n", absoluteAmount, transaction.Amount)
			}
		} else {
			if data.Amount < 0 {
				absoluteAmount := e.provider.Service.Decimal.Abs(data.Amount)
				transaction.Amount = e.provider.Service.Decimal.Subtract(transaction.Amount, absoluteAmount)
				fmt.Printf("[dbg] normal & negative: subtract %v -> transaction.Amount=%v\n", absoluteAmount, transaction.Amount)
			} else {
				absoluteAmount := e.provider.Service.Decimal.Abs(data.Amount)
				transaction.Amount = e.provider.Service.Decimal.Add(transaction.Amount, absoluteAmount)
				fmt.Printf("[dbg] normal & positive: add %v -> transaction.Amount=%v\n", absoluteAmount, transaction.Amount)
			}
		}
	case core.GeneralLedgerSourceWithdraw:
		if data.Reverse {
			if data.Amount < 0 {
				absoluteAmount := e.provider.Service.Decimal.Abs(data.Amount)
				transaction.Amount = e.provider.Service.Decimal.Subtract(transaction.Amount, absoluteAmount)
				fmt.Printf("[dbg] withdraw reverse & negative: subtract %v -> transaction.Amount=%v\n", absoluteAmount, transaction.Amount)
			} else {
				absoluteAmount := e.provider.Service.Decimal.Abs(data.Amount)
				transaction.Amount = e.provider.Service.Decimal.Add(transaction.Amount, absoluteAmount)
				fmt.Printf("[dbg] withdraw reverse & positive: add %v -> transaction.Amount=%v\n", absoluteAmount, transaction.Amount)
			}
		} else {
			if data.Amount < 0 {
				absoluteAmount := e.provider.Service.Decimal.Abs(data.Amount)
				transaction.Amount = e.provider.Service.Decimal.Add(transaction.Amount, absoluteAmount)
				fmt.Printf("[dbg] withdraw normal & negative: add %v -> transaction.Amount=%v\n", absoluteAmount, transaction.Amount)
			} else {
				absoluteAmount := e.provider.Service.Decimal.Abs(data.Amount)
				transaction.Amount = e.provider.Service.Decimal.Subtract(transaction.Amount, absoluteAmount)
				fmt.Printf("[dbg] withdraw normal & positive: subtract %v -> transaction.Amount=%v\n", absoluteAmount, transaction.Amount)
			}
		}
	}

	transaction.UpdatedAt = now
	transaction.UpdatedByID = userOrg.UserID
	fmt.Printf("[dbg] updating transaction ID=%v Amount=%v\n", transaction.ID, transaction.Amount)
	if err := e.core.TransactionManager.UpdateByIDWithTx(context, tx, transaction.ID, transaction); err != nil {
		fmt.Println("[dbg] error updating transaction")
		e.Footstep(ctx, FootstepEvent{
			Activity:    "transaction-update-error",
			Description: "Failed to update transaction (/transaction/payment/:transaction_id): " + err.Error(),
			Module:      "Transaction",
		})
		block("Failed to update transaction: " + err.Error())
		return nil, endTx(eris.Wrap(err, "failed to update transaction"))
	}
	fmt.Println("[dbg] transaction updated")

	cashOnHandGeneralLedger := &core.GeneralLedger{
		CreatedAt:                  now,
		CreatedByID:                userOrg.UserID,
		UpdatedAt:                  now,
		UpdatedByID:                userOrg.UserID,
		BranchID:                   *userOrg.BranchID,
		OrganizationID:             userOrg.OrganizationID,
		TransactionBatchID:         &transactionBatch.ID,
		ReferenceNumber:            referenceNumber,
		TransactionID:              &transaction.ID,
		EntryDate:                  userOrgTime,
		SignatureMediaID:           data.SignatureMediaID,
		ProofOfPaymentMediaID:      data.ProofOfPaymentMediaID,
		BankID:                     data.BankID,
		AccountID:                  cashOnHandAccountID,
		MemberProfileID:            memberProfileID,
		MemberJointAccountID:       memberJointAccountID,
		PaymentTypeID:              &paymentType.ID,
		TransactionReferenceNumber: data.ReferenceNumber,
		Source:                     data.Source,
		BankReferenceNumber:        data.BankReferenceNumber,
		EmployeeUserID:             &userOrg.UserID,
		Description:                data.Description,
		TypeOfPaymentType:          paymentType.Type,
		Credit:                     debit,
		Debit:                      credit,
		CurrencyID:                 account.CurrencyID,
		Account:                    cashOnHandAccount,
	}
	fmt.Printf("[dbg] creating cash on hand ledger entry: %+v\n", cashOnHandGeneralLedger)
	if err := e.core.CreateGeneralLedgerEntry(context, tx, cashOnHandGeneralLedger); err != nil {
		fmt.Println("[dbg] error creating cash on hand general ledger entry")
		e.Footstep(ctx, FootstepEvent{
			Activity:    "ledger-create-error",
			Description: "Failed to create general ledger entry (/transaction/payment/:transaction_id): " + err.Error(),
			Module:      "Transaction",
		})
		block("Failed to create general ledger entry for cash on hand: " + err.Error())
		return nil, endTx(eris.Wrap(err, "failed to create general ledger entry for cash on hand"))
	}
	fmt.Printf("[dbg] cash on hand ledger entry created: ID=%v\n", cashOnHandGeneralLedger.ID)

	fmt.Println("[dbg] balancing transaction batch")
	if err := e.TransactionBatchBalancing(context, &transactionBatch.ID); err != nil {
		fmt.Printf("[dbg] error balancing transaction batch: %v\n", err)
		return nil, endTx(eris.Wrap(err, "failed to balance transaction batch"))
	}
	fmt.Println("[dbg] transaction batch balanced")

	fmt.Println("[dbg] committing transaction with endTx(nil)")
	if err := endTx(nil); err != nil {
		fmt.Printf("[dbg] error on commit: %v\n", err)
		e.Footstep(ctx, FootstepEvent{
			Activity:    "db-commit-error",
			Description: "Failed to commit transaction (/transaction/payment/:transaction_id): " + err.Error(),
			Module:      "Transaction",
		})
		return nil, endTx(eris.Wrap(err, "failed to commit transaction"))
	}

	duration := time.Since(startTime)
	e.Footstep(ctx, FootstepEvent{
		Activity: "payment-success",
		Description: fmt.Sprintf("Payment completed successfully. Amount: %.2f, Account: %s, Duration: %.3fs (/transaction/payment/:transaction_id)",
			data.Amount, data.AccountID.String(), duration.Seconds()),
		Module: "Transaction",
	})
	fmt.Printf("[dbg] payment success: Amount=%v Account=%v duration=%v\n", data.Amount, data.AccountID, duration)

	return newGeneralLedger, nil
}
